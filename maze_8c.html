<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Leptonica: src/maze.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="moller52-tiny.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Leptonica&#160;<span id="projectnumber">1.68</span></div>
   <div id="projectbrief">C Image Processing Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('maze_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>maze.c File Reference</h1>  </div>
</div>
<div class="contents">

<p>A game with a pedagogical slant: generate and search binary and grayscale mazes.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="allheaders_8h_source.html">allheaders.h</a>&quot;</code><br/>
</div>
<p><a href="maze_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_maze_element.html">MazeElement</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#aa88c629f16157e7ff17dd464f9cc9b86">DEBUG_PATH</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#a317f934d6259c43a3987df7cc7e4fa9e">DEBUG_MAZE</a>&#160;&#160;&#160;0</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_maze_element.html">MazeElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#aecc3b4ac113ccbe0e1b9fc0a66bb9d06">MAZEEL</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<a class="el" href="maze_8c.html#a05589fbab0657f08285ebdfe93f5ec9eaa46c058dbde207810c7eadf317b74b56">START_LOC</a> =  0, 
<a class="el" href="maze_8c.html#a05589fbab0657f08285ebdfe93f5ec9ea944af66843e2c071955de8dfc4e7f407">DIR_NORTH</a> =  1, 
<a class="el" href="maze_8c.html#a05589fbab0657f08285ebdfe93f5ec9eac389b73c4b4c522960337089a197269e">DIR_SOUTH</a> =  2, 
<a class="el" href="maze_8c.html#a05589fbab0657f08285ebdfe93f5ec9ead1a68523fb1c95ab84e942f8f00015c7">DIR_WEST</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="maze_8c.html#a05589fbab0657f08285ebdfe93f5ec9ea42e7113a3046ccc33a89838be245ddaf">DIR_EAST</a> =  4
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_maze_element.html">MAZEEL</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#acf97ed53c4b812a8f42f26b6080a0127">mazeelCreate</a> (<a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> x, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> y, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#a31b93cc1dd8eb30ed9ff0a43b21e5c4e">localSearchForBackground</a> (<a class="el" href="struct_pix.html">PIX</a> *pix, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *px, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *py, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> maxrad)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#a9a76fb68b86bf62adc9bf6db8c50a5eb">generateBinaryMaze</a> (<a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> w, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> h, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> xi, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> yi, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> wallps, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> ranis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#ac6b7f944eafad8caad196f7efe874041">pixSearchBinaryMaze</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> xi, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> yi, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> xf, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> yf, <a class="el" href="struct_pix.html">PIX</a> **ppixd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#ab710b8979904e43632704d0719b31246">pixSearchGrayMaze</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> xi, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> yi, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> xf, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> yf, <a class="el" href="struct_pix.html">PIX</a> **ppixd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#af089d7a279378ffca063f261778e0084">pixFindLargestRectangle</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> polarity, <a class="el" href="struct_box.html">BOX</a> **pbox, const char *debugfile)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#a14ffedea9456493376845cf23421b066">MIN_MAZE_WIDTH</a> = 50</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#a866f47944f2e66c523961f8c04f5ce1e">MIN_MAZE_HEIGHT</a> = 50</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#aeb91e65a73c092ee574318b28a1620dc">DEFAULT_WALL_PROBABILITY</a> = 0.65</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="maze_8c.html#a9b55ed4c14a8d8a98bdd195d3207822c">DEFAULT_ANISOTROPY_RATIO</a> = 0.25</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A game with a pedagogical slant: generate and search binary and grayscale mazes. </p>

<p>Definition in file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="aa88c629f16157e7ff17dd464f9cc9b86"></a><!-- doxytag: member="maze.c::DEBUG_PATH" ref="aa88c629f16157e7ff17dd464f9cc9b86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_PATH&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="maze_8c_source.html#l00084">84</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

</div>
</div>
<a class="anchor" id="a317f934d6259c43a3987df7cc7e4fa9e"></a><!-- doxytag: member="maze.c::DEBUG_MAZE" ref="a317f934d6259c43a3987df7cc7e4fa9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_MAZE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="maze_8c_source.html#l00085">85</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aecc3b4ac113ccbe0e1b9fc0a66bb9d06"></a><!-- doxytag: member="maze.c::MAZEEL" ref="aecc3b4ac113ccbe0e1b9fc0a66bb9d06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_maze_element.html">MazeElement</a> <a class="el" href="struct_maze_element.html">MAZEEL</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="maze_8c_source.html#l00076">76</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a05589fbab0657f08285ebdfe93f5ec9e"></a><!-- doxytag: member="maze.c::@13" ref="a05589fbab0657f08285ebdfe93f5ec9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a05589fbab0657f08285ebdfe93f5ec9eaa46c058dbde207810c7eadf317b74b56"></a><!-- doxytag: member="START_LOC" ref="a05589fbab0657f08285ebdfe93f5ec9eaa46c058dbde207810c7eadf317b74b56" args="" -->START_LOC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a05589fbab0657f08285ebdfe93f5ec9ea944af66843e2c071955de8dfc4e7f407"></a><!-- doxytag: member="DIR_NORTH" ref="a05589fbab0657f08285ebdfe93f5ec9ea944af66843e2c071955de8dfc4e7f407" args="" -->DIR_NORTH</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a05589fbab0657f08285ebdfe93f5ec9eac389b73c4b4c522960337089a197269e"></a><!-- doxytag: member="DIR_SOUTH" ref="a05589fbab0657f08285ebdfe93f5ec9eac389b73c4b4c522960337089a197269e" args="" -->DIR_SOUTH</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a05589fbab0657f08285ebdfe93f5ec9ead1a68523fb1c95ab84e942f8f00015c7"></a><!-- doxytag: member="DIR_WEST" ref="a05589fbab0657f08285ebdfe93f5ec9ead1a68523fb1c95ab84e942f8f00015c7" args="" -->DIR_WEST</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a05589fbab0657f08285ebdfe93f5ec9ea42e7113a3046ccc33a89838be245ddaf"></a><!-- doxytag: member="DIR_EAST" ref="a05589fbab0657f08285ebdfe93f5ec9ea42e7113a3046ccc33a89838be245ddaf" args="" -->DIR_EAST</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="maze_8c_source.html#l00061">61</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="acf97ed53c4b812a8f42f26b6080a0127"></a><!-- doxytag: member="maze.c::mazeelCreate" ref="acf97ed53c4b812a8f42f26b6080a0127" args="(l_int32 x, l_int32 y, l_int32 dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_maze_element.html">MAZEEL</a> * mazeelCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="maze_8c_source.html#l00271">271</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="maze_8c_source.html#l00074">MazeElement::dir</a>, <a class="el" href="maze_8c_source.html#l00071">MazeElement::x</a>, and <a class="el" href="maze_8c_source.html#l00072">MazeElement::y</a>.</p>

<p>Referenced by <a class="el" href="maze_8c_source.html#l00133">generateBinaryMaze()</a>, <a class="el" href="maze_8c_source.html#l00332">pixSearchBinaryMaze()</a>, and <a class="el" href="maze_8c_source.html#l00718">pixSearchGrayMaze()</a>.</p>

</div>
</div>
<a class="anchor" id="a31b93cc1dd8eb30ed9ff0a43b21e5c4e"></a><!-- doxytag: member="maze.c::localSearchForBackground" ref="a31b93cc1dd8eb30ed9ff0a43b21e5c4e" args="(PIX *pix, l_int32 *px, l_int32 *py, l_int32 maxrad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> localSearchForBackground </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>py</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>maxrad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="maze_8c.html#a31b93cc1dd8eb30ed9ff0a43b21e5c4e">localSearchForBackground()</a></p>
<p>Input: &amp;x, &amp;y (starting position for search; return found position) maxrad (max distance to search from starting location) Return: 0 if bg pixel found; 1 if not found </p>

<p>Definition at line <a class="el" href="maze_8c_source.html#l00521">521</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00159">L_ABS</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix2_8c_source.html#l00148">pixGetPixel()</a>, <a class="el" href="maze_8c_source.html#l00073">MazeElement::val</a>, <a class="el" href="maze_8c_source.html#l00071">MazeElement::x</a>, and <a class="el" href="maze_8c_source.html#l00072">MazeElement::y</a>.</p>

<p>Referenced by <a class="el" href="maze_8c_source.html#l00332">pixSearchBinaryMaze()</a>.</p>

</div>
</div>
<a class="anchor" id="a9a76fb68b86bf62adc9bf6db8c50a5eb"></a><!-- doxytag: member="maze.c::generateBinaryMaze" ref="a9a76fb68b86bf62adc9bf6db8c50a5eb" args="(l_int32 w, l_int32 h, l_int32 xi, l_int32 yi, l_float32 wallps, l_float32 ranis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* generateBinaryMaze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>wallps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>ranis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="leptprotos_8h.html#ad476e82c35fb8352461d2246c4fce9b9">generateBinaryMaze()</a></p>
<p>Input: w, h (size of maze) xi, yi (initial location) wallps (probability that a pixel to the side is ON) ranis (ratio of prob that pixel in forward direction is a wall to the probability that pixel in side directions is a wall) Return: pix, or null on error</p>
<p>Notes: (1) We have two input probability factors that determine the density of walls and average length of straight passages. When ranis &lt; 1.0, you are more likely to generate a wall to the side than going forward. Enter 0.0 for either if you want to use the default values. (2) This is a type of percolation problem, and exhibits different phases for different parameters wallps and ranis. For larger values of these parameters, regions in the maze are not explored because the maze generator walls them off and cannot get through. The boundary between the two phases in this two-dimensional parameter space goes near these values: wallps ranis 0.35 1.00 0.40 0.85 0.45 0.70 0.50 0.50 0.55 0.40 0.60 0.30 0.65 0.25 0.70 0.19 0.75 0.15 0.80 0.11 (3) Because here is a considerable amount of overhead in calling <a class="el" href="leptprotos_8h.html#a9888f4d973b7bf8516a579e5bdb67d21">pixGetPixel()</a> and <a class="el" href="leptprotos_8h.html#a1b7576238fbc20a2b6bf2aab8d8d7f6a">pixSetPixel()</a>, this function can be sped up with little effort using raster line pointers and the GET_DATA* and SET_DATA* macros. </p>

<p>Definition at line <a class="el" href="maze_8c_source.html#l00133">133</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>References <a class="el" href="maze_8c_source.html#l00059">DEFAULT_ANISOTROPY_RATIO</a>, <a class="el" href="maze_8c_source.html#l00058">DEFAULT_WALL_PROBABILITY</a>, <a class="el" href="maze_8c_source.html#l00074">MazeElement::dir</a>, <a class="el" href="maze_8c_source.html#l00066">DIR_EAST</a>, <a class="el" href="maze_8c_source.html#l00063">DIR_NORTH</a>, <a class="el" href="maze_8c_source.html#l00064">DIR_SOUTH</a>, <a class="el" href="maze_8c_source.html#l00065">DIR_WEST</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="queue_8c_source.html#l00167">lqueueAdd()</a>, <a class="el" href="queue_8c_source.html#l00074">lqueueCreate()</a>, <a class="el" href="queue_8c_source.html#l00112">lqueueDestroy()</a>, <a class="el" href="queue_8c_source.html#l00261">lqueueGetCount()</a>, <a class="el" href="queue_8c_source.html#l00232">lqueueRemove()</a>, <a class="el" href="maze_8c_source.html#l00271">mazeelCreate()</a>, <a class="el" href="maze_8c_source.html#l00056">MIN_MAZE_HEIGHT</a>, <a class="el" href="maze_8c_source.html#l00055">MIN_MAZE_WIDTH</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix2_8c_source.html#l00148">pixGetPixel()</a>, <a class="el" href="pix2_8c_source.html#l00219">pixSetPixel()</a>, <a class="el" href="maze_8c_source.html#l00062">START_LOC</a>, <a class="el" href="environ_8h_source.html#l00175">TRUE</a>, <a class="el" href="maze_8c_source.html#l00073">MazeElement::val</a>, <a class="el" href="maze_8c_source.html#l00071">MazeElement::x</a>, and <a class="el" href="maze_8c_source.html#l00072">MazeElement::y</a>.</p>

<p>Referenced by <a class="el" href="maze__reg_8c_source.html#l00035">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6b7f944eafad8caad196f7efe874041"></a><!-- doxytag: member="maze.c::pixSearchBinaryMaze" ref="ac6b7f944eafad8caad196f7efe874041" args="(PIX *pixs, l_int32 xi, l_int32 yi, l_int32 xf, l_int32 yf, PIX **ppixd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pta.html">PTA</a>* pixSearchBinaryMaze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>xf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>yf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> **&#160;</td>
          <td class="paramname"><em>ppixd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="leptprotos_8h.html#a25520d0769dc2cc6563ec70b338351fc">pixSearchBinaryMaze()</a></p>
<p>Input: pixs (1 bpp, maze) xi, yi (beginning point; use same initial point that was used to generate the maze) xf, yf (end point, or close to it) &amp;ppixd (&lt;optional return&gt;=""&gt; maze with path illustrated, or if no path possible, the part of the maze that was searched) Return: pta (shortest path), or null if either no path exists or on error</p>
<p>Notes: (1) Because of the overhead in calling <a class="el" href="leptprotos_8h.html#a9888f4d973b7bf8516a579e5bdb67d21">pixGetPixel()</a> and <a class="el" href="leptprotos_8h.html#a1b7576238fbc20a2b6bf2aab8d8d7f6a">pixSetPixel()</a>, we have used raster line pointers and the GET_DATA* and SET_DATA* macros for many of the pix accesses. (2) Commentary: The goal is to find the shortest path between beginning and end points, without going through walls, and there are many ways to solve this problem. We use a queue to implement a breadth-first search. Two auxiliary "image" data structures can be used: one to mark the visited pixels and one to give the direction to the parent for each visited pixels. The first structure is used to avoid putting pixels on the queue more than once, and the second is used for retracing back to the origin, like the breadcrumbs in Hansel and Gretel. Each pixel taken off the queue is destroyed after it is used to locate the allowed neighbors. In fact, only one distance image is required, if you initialize it to some value that signifies "not yet visited." (We use a binary image for marking visited pixels because it is clearer.) This method for a simple search of a binary maze is implemented in searchBinaryMaze(). An alternative method would store the (manhattan) distance from the start point with each pixel on the queue. The children of each pixel get a distance one larger than the parent. These values can be stored in an auxiliary distance map image that is constructed simultaneously with the search. Once the end point is reached, the distance map is used to backtrack along a minimum path. There may be several equal length minimum paths, any one of which can be chosen this way. </p>

<p>Definition at line <a class="el" href="maze_8c_source.html#l00332">332</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>References <a class="el" href="pix2_8c_source.html#l02076">composeRGBPixel()</a>, <a class="el" href="maze_8c_source.html#l00066">DIR_EAST</a>, <a class="el" href="maze_8c_source.html#l00063">DIR_NORTH</a>, <a class="el" href="maze_8c_source.html#l00064">DIR_SOUTH</a>, <a class="el" href="maze_8c_source.html#l00065">DIR_WEST</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00179">FALSE</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00060">GET_DATA_BIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="environ_8h_source.html#l00263">L_INFO</a>, <a class="el" href="maze_8c_source.html#l00521">localSearchForBackground()</a>, <a class="el" href="queue_8c_source.html#l00167">lqueueAdd()</a>, <a class="el" href="queue_8c_source.html#l00074">lqueueCreate()</a>, <a class="el" href="queue_8c_source.html#l00112">lqueueDestroy()</a>, <a class="el" href="queue_8c_source.html#l00261">lqueueGetCount()</a>, <a class="el" href="queue_8c_source.html#l00232">lqueueRemove()</a>, <a class="el" href="maze_8c_source.html#l00271">mazeelCreate()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l01527">pixGetLinePtrs()</a>, <a class="el" href="pix2_8c_source.html#l00148">pixGetPixel()</a>, <a class="el" href="pix2_8c_source.html#l00219">pixSetPixel()</a>, <a class="el" href="pixconv_8c_source.html#l01387">pixUnpackBinary()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="ptabasic_8c_source.html#l00262">ptaAddPt()</a>, <a class="el" href="ptabasic_8c_source.html#l00083">ptaCreate()</a>, <a class="el" href="arrayaccess_8h_source.html#l00063">SET_DATA_BIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00157">SET_DATA_FOUR_BYTES</a>, <a class="el" href="environ_8h_source.html#l00175">TRUE</a>, <a class="el" href="maze_8c_source.html#l00073">MazeElement::val</a>, <a class="el" href="maze_8c_source.html#l00071">MazeElement::x</a>, and <a class="el" href="maze_8c_source.html#l00072">MazeElement::y</a>.</p>

<p>Referenced by <a class="el" href="maze__reg_8c_source.html#l00035">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ab710b8979904e43632704d0719b31246"></a><!-- doxytag: member="maze.c::pixSearchGrayMaze" ref="ab710b8979904e43632704d0719b31246" args="(PIX *pixs, l_int32 xi, l_int32 yi, l_int32 xf, l_int32 yf, PIX **ppixd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pta.html">PTA</a>* pixSearchGrayMaze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>xi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>yi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>xf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>yf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> **&#160;</td>
          <td class="paramname"><em>ppixd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="leptprotos_8h.html#a1209a9406288add100aa96e596955204">pixSearchGrayMaze()</a></p>
<p>Input: pixs (1 bpp, maze) xi, yi (beginning point; use same initial point that was used to generate the maze) xf, yf (end point, or close to it) &amp;ppixd (&lt;optional return&gt;=""&gt; maze with path illustrated, or if no path possible, the part of the maze that was searched) Return: pta (shortest path), or null if either no path exists or on error</p>
<p>Commentary: Consider first a slight generalization of the binary maze search problem. Suppose that you can go through walls, but the cost is higher (say, an increment of 3 to go into a wall pixel rather than 1)? You're still trying to find the shortest path. One way to do this is with an ordered queue, and a simple way to visualize an ordered queue is as a set of stacks, each stack being marked with the distance of each pixel in the stack from the start. We place the start pixel in stack 0, pop it, and process its 4 children. Each pixel is given a distance that is incremented from that of its parent (0 in this case), depending on if it is a wall pixel or not. That value may be recorded on a distance map, according to the algorithm below. For children of the first pixel, those not on a wall go in stack 1, and wall children go in stack 3. Stack 0 being emptied, the process then continues with pixels being popped from stack 1. Here is the algorithm for each child pixel. The pixel's distance value, were it to be placed on a stack, is compared with the value for it that is on the distance map. There are three possible cases: (1) If the pixel has not yet been registered, it is pushed on its stack and the distance is written to the map. (2) If it has previously been registered with a higher distance, the distance on the map is relaxed to that of the current pixel, which is then placed on its stack. (3) If it has previously been registered with an equal or lower value, the pixel is discarded. The pixels are popped and processed successively from stack 1, and when stack 1 is empty, popping starts on stack 2. This continues until the destination pixel is popped off a stack. The minimum path is then derived from the distance map, going back from the end point as before. This is just Dijkstra's algorithm for a directed graph; here, the underlying graph (consisting of the pixels and four edges connecting each pixel to its 4-neighbor) is a special case of a directed graph, where each edge is bi-directional. The implementation of this generalized maze search is left as an exercise to the reader.</p>
<p>Let's generalize a bit further. Suppose the "maze" is just a grayscale image -- think of it as an elevation map. The cost of moving on this surface depends on the height, or the gradient, or whatever you want. All that is required is that the cost is specified and non-negative on each link between adjacent pixels. Now the problem becomes: find the least cost path moving on this surface between two specified end points. For example, if the cost across an edge between two pixels depends on the "gradient", you can use: cost = 1 + <a class="el" href="environ_8h.html#ad422c21d3f8664d230423cf5638b0e6e">L_ABS(deltaV)</a> where deltaV is the difference in value between two adjacent pixels. If the costs are all integers, we can still use an array of stacks to avoid ordering the queue (e.g., by using a heap sort.) This is a neat problem, because you don't even have to build a maze -- you can can use it on any grayscale image!</p>
<p>Rather than using an array of stacks, a more practical approach is to implement with a priority queue, which is a queue that is sorted so that the elements with the largest (or smallest) key values always come off first. The priority queue is efficiently implemented as a heap, and this is how we do it. Suppose you run the algorithm using a priority queue, doing the bookkeeping with an auxiliary image data structure that saves the distance of each pixel put on the queue as before, according to the method described above. We implement it as a 2-way choice by initializing the distance array to a large value and putting a pixel on the queue if its distance is less than the value found on the array. When you finally pop the end pixel from the queue, you're done, and you can trace the path backward, either always going downhill or using an auxiliary image to give you the direction to go at each step. This is implemented here in searchGrayMaze().</p>
<p>Do we really have to use a sorted queue? Can we solve this generalized maze with an unsorted queue of pixels? (Or even an unsorted stack, doing a depth-first search (DFS)?) Consider a different algorithm for this generalized maze, where we travel again breadth first, but this time use a single, unsorted queue. An auxiliary image is used as before to store the distances and to determine if pixels get pushed on the stack or dropped. As before, we must allow pixels to be revisited, with relaxation of the distance if a shorter path arrives later. As a result, we will in general have multiple instances of the same pixel on the stack with different distances. However, because the queue is not ordered, some of these pixels will be popped when another instance with a lower distance is still on the stack. Here, we're just popping them in the order they go on, rather than setting up a priority based on minimum distance. Thus, unlike the priority queue, when a pixel is popped we have to check the distance map to see if a pixel with a lower distance has been put on the queue, and, if so, we discard the pixel we just popped. So the "while" loop looks like this:</p>
<ul>
<li>pop a pixel from the queue</li>
<li>check its distance against the distance stored in the distance map; if larger, discard</li>
<li>otherwise, for each of its neighbors:<ul>
<li>compute its distance from the start pixel</li>
<li>compare this distance with that on the distance map:<ul>
<li>if the distance map value higher, relax the distance and push the pixel on the queue</li>
<li>if the distance map value is lower, discard the pixel</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>How does this loop terminate? Before, with an ordered queue, it terminates when you pop the end pixel. But with an unordered queue (or stack), the first time you hit the end pixel, the distance is not guaranteed to be correct, because the pixels along the shortest path may not have yet been visited and relaxed. Because the shortest path can theoretically go anywhere, we must keep going. How do we know when to stop? Dijkstra uses an ordered queue to systematically remove nodes from further consideration. (Each time a pixel is popped, we're done with it; it's "finalized" in the Dijkstra sense because we know the shortest path to it.) However, with an unordered queue, the brute force answer is: stop when the queue (or stack) is empty, because then every pixel in the image has been assigned its minimum "distance" from the start pixel.</p>
<p>This is similar to the situation when you use a stack for the simpler uniform-step problem: with breadth-first search (BFS) the pixels on the queue are automatically ordered, so you are done when you locate the end pixel as a neighbor of a popped pixel; whereas depth-first search (DFS), using a stack, requires, in general, a search of every accessible pixel. Further, if a pixel is revisited with a smaller distance, that distance is recorded and the pixel is put on the stack again.</p>
<p>But surely, you ask, can't we stop sooner? What if the start and end pixels are very close to each other? OK, suppose they are, and you have very high walls and a long snaking level path that is actually the minimum cost. That long path can wind back and forth across the entire maze many times before ending up at the end point, which could be just over a wall from the start. With the unordered queue, you very quickly get a high distance for the end pixel, which will be relaxed to the minimum distance only after all the pixels of the path have been visited and placed on the queue, multiple times for many of them. So that's the price for not ordering the queue! </p>

<p>Definition at line <a class="el" href="maze_8c_source.html#l00718">718</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>References <a class="el" href="pix2_8c_source.html#l02076">composeRGBPixel()</a>, <a class="el" href="maze_8c_source.html#l00066">DIR_EAST</a>, <a class="el" href="maze_8c_source.html#l00063">DIR_NORTH</a>, <a class="el" href="maze_8c_source.html#l00064">DIR_SOUTH</a>, <a class="el" href="maze_8c_source.html#l00065">DIR_WEST</a>, <a class="el" href="maze_8c_source.html#l00070">MazeElement::distance</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00154">GET_DATA_FOUR_BYTES</a>, <a class="el" href="environ_8h_source.html#l00159">L_ABS</a>, <a class="el" href="pix_8h_source.html#l00609">L_SORT_INCREASING</a>, <a class="el" href="heap_8c_source.html#l00168">lheapAdd()</a>, <a class="el" href="heap_8c_source.html#l00088">lheapCreate()</a>, <a class="el" href="heap_8c_source.html#l00127">lheapDestroy()</a>, <a class="el" href="heap_8c_source.html#l00253">lheapGetCount()</a>, <a class="el" href="heap_8c_source.html#l00224">lheapRemove()</a>, <a class="el" href="maze_8c_source.html#l00271">mazeelCreate()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pixconv_8c_source.html#l02542">pixConvert8To32()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l01527">pixGetLinePtrs()</a>, <a class="el" href="pix2_8c_source.html#l00148">pixGetPixel()</a>, <a class="el" href="pix2_8c_source.html#l00625">pixSetAll()</a>, <a class="el" href="pix2_8c_source.html#l00219">pixSetPixel()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="ptabasic_8c_source.html#l00262">ptaAddPt()</a>, <a class="el" href="ptabasic_8c_source.html#l00083">ptaCreate()</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00157">SET_DATA_FOUR_BYTES</a>, <a class="el" href="environ_8h_source.html#l00175">TRUE</a>, <a class="el" href="maze_8c_source.html#l00073">MazeElement::val</a>, <a class="el" href="maze_8c_source.html#l00071">MazeElement::x</a>, and <a class="el" href="maze_8c_source.html#l00072">MazeElement::y</a>.</p>

<p>Referenced by <a class="el" href="maze__reg_8c_source.html#l00035">main()</a>.</p>

</div>
</div>
<a class="anchor" id="af089d7a279378ffca063f261778e0084"></a><!-- doxytag: member="maze.c::pixFindLargestRectangle" ref="af089d7a279378ffca063f261778e0084" args="(PIX *pixs, l_int32 polarity, BOX **pbox, const char *debugfile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> pixFindLargestRectangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>polarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_box.html">BOX</a> **&#160;</td>
          <td class="paramname"><em>pbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>debugfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="leptprotos_8h.html#a822312ac8e82c3fa08355294d2f8e22b">pixFindLargestRectangle()</a></p>
<p>Input: pixs (1 bpp) polarity (0 within background, 1 within foreground) &amp;box (&lt;return&gt; largest rectangle, either by area or by perimeter) debugflag (1 to output image with rectangle drawn on it) Return: 0 if OK, 1 on error</p>
<p>Notes: (1) Why is this here? This is a simple and elegant solution to a problem in computational geometry that at first appears quite difficult: what is the largest rectangle that can be placed in the image, covering only pixels of one polarity (bg or fg)? The solution is O(n), where n is the number of pixels in the image, and it requires nothing more than using a simple recursion relation in a single sweep of the image. (2) In a sweep from UL to LR with left-to-right being the fast direction, calculate the largest white rectangle at (x, y), using previously calculated values at pixels #1 and #2: #1: (x, y - 1) #2: (x - 1, y) We also need the most recent "black" pixels that were seen in the current row and column. Consider the largest area. There are only two possibilities: (a) Min(w(1), horizdist) * (h(1) + 1) (b) Min(h(2), vertdist) * (w(2) + 1) where horizdist: the distance from the rightmost "black" pixel seen in the current row across to the current pixel vertdist: the distance from the lowest "black" pixel seen in the current column down to the current pixel and we choose the Max of (a) and (b). (3) To convince yourself that these recursion relations are correct, it helps to draw the maximum rectangles at #1 and #2. Then for #1, you try to extend the rectangle down one line, so that the height is h(1) + 1. Do you get the full width of #1, w(1)? It depends on where the black pixels are in the current row. You know the final width is bounded by w(1) and w(2) + 1, but the actual value depends on the distribution of black pixels in the current row that are at a distance from the current pixel that is between these limits. We call that value "horizdist", and the area is then given by the expression (a) above. Using similar reasoning for #2, where you attempt to extend the rectangle to the right by 1 pixel, you arrive at (b). The largest rectangle is then found by taking the Max. </p>

<p>Definition at line <a class="el" href="maze_8c_source.html#l00953">953</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>References <a class="el" href="boxbasic_8c_source.html#l00133">boxCreate()</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00060">GET_DATA_BIT</a>, <a class="el" href="imageio_8h_source.html#l00038">IFF_PNG</a>, <a class="el" href="environ_8h_source.html#l00151">L_MIN</a>, <a class="el" href="pix_8h_source.html#l00809">L_NEG_SLOPE_LINE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pixconv_8c_source.html#l02297">pixConvertTo8()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l01527">pixGetLinePtrs()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="graphics_8c_source.html#l01197">pixRenderHashBoxArb()</a>, <a class="el" href="writefile_8c_source.html#l00190">pixWrite()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="environ_8h_source.html#l00175">TRUE</a>, and <a class="el" href="maze_8c_source.html#l00073">MazeElement::val</a>.</p>

<p>Referenced by <a class="el" href="maze__reg_8c_source.html#l00035">main()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a14ffedea9456493376845cf23421b066"></a><!-- doxytag: member="maze.c::MIN_MAZE_WIDTH" ref="a14ffedea9456493376845cf23421b066" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="maze_8c.html#a14ffedea9456493376845cf23421b066">MIN_MAZE_WIDTH</a> = 50<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="maze_8c_source.html#l00055">55</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>Referenced by <a class="el" href="maze_8c_source.html#l00133">generateBinaryMaze()</a>.</p>

</div>
</div>
<a class="anchor" id="a866f47944f2e66c523961f8c04f5ce1e"></a><!-- doxytag: member="maze.c::MIN_MAZE_HEIGHT" ref="a866f47944f2e66c523961f8c04f5ce1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="maze_8c.html#a866f47944f2e66c523961f8c04f5ce1e">MIN_MAZE_HEIGHT</a> = 50<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="maze_8c_source.html#l00056">56</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>Referenced by <a class="el" href="maze_8c_source.html#l00133">generateBinaryMaze()</a>.</p>

</div>
</div>
<a class="anchor" id="aeb91e65a73c092ee574318b28a1620dc"></a><!-- doxytag: member="maze.c::DEFAULT_WALL_PROBABILITY" ref="aeb91e65a73c092ee574318b28a1620dc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> <a class="el" href="maze_8c.html#aeb91e65a73c092ee574318b28a1620dc">DEFAULT_WALL_PROBABILITY</a> = 0.65<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="maze_8c_source.html#l00058">58</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>Referenced by <a class="el" href="maze_8c_source.html#l00133">generateBinaryMaze()</a>.</p>

</div>
</div>
<a class="anchor" id="a9b55ed4c14a8d8a98bdd195d3207822c"></a><!-- doxytag: member="maze.c::DEFAULT_ANISOTROPY_RATIO" ref="a9b55ed4c14a8d8a98bdd195d3207822c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> <a class="el" href="maze_8c.html#a9b55ed4c14a8d8a98bdd195d3207822c">DEFAULT_ANISOTROPY_RATIO</a> = 0.25<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="maze_8c_source.html#l00059">59</a> of file <a class="el" href="maze_8c_source.html">maze.c</a>.</p>

<p>Referenced by <a class="el" href="maze_8c_source.html#l00133">generateBinaryMaze()</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="maze_8c.html">maze.c</a>      </li>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
