<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Leptonica: src/grayquant.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="moller52-tiny.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Leptonica&#160;<span id="projectnumber">1.68</span></div>
   <div id="projectbrief">C Image Processing Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('grayquant_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>grayquant.c File Reference</h1>  </div>
</div>
<div class="contents">

<p>Standard, simple, general grayscale quantization.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="allheaders_8h_source.html">allheaders.h</a>&quot;</code><br/>
</div>
<p><a href="grayquant_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#acacc3a64b1f2a391a58ca11a961ac2de">numaFillCmapFromHisto</a> (<a class="el" href="struct_numa.html">NUMA</a> *na, <a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *cmap, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> minfract, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="overlap__reg_8c.html#a332ff7829674eedb7280f7ea608e11c3">maxsize</a>, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> **plut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#acaa60003b944a27639db5df7f4ea2de4">pixDitherToBinary</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#ab4f56a43143491151bee008a0ad33478">pixDitherToBinarySpec</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> lowerclip, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> upperclip)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#ae860cea63ac0db20d92af73cf17f37c7">pixThresholdToBinary</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> thresh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#ab3cd276d0ba9aabdcc7a2165724aab7b">pixVarThresholdToBinary</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pix.html">PIX</a> *pixg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#abf3d8b88984f004aae26e0b46db7b000">pixDitherToBinaryLUT</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> lowerclip, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> upperclip)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a7b1ce9bba23ca636b5a375f82c5d9759">pixGenerateMaskByValue</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> val, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> usecmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a8cb4b4a02dd87f6b6577af59acdb13f4">pixGenerateMaskByBand</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> lower, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> upper, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> inband, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> usecmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a6b38a8f5e0d12b077cb002545d3d14eb">pixDitherTo2bpp</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> cmapflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#ab95548869f5ef1cedca1974bec7b6b5d">pixDitherTo2bppSpec</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> lowerclip, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> upperclip, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> cmapflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a28f0a87372b62df5b1480f58136823d1">pixThresholdTo2bpp</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="pixalloc__reg_8c.html#a403607c6ab768f89805d4fa62904488f">nlevels</a>, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> cmapflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a3ceb912e2683196af6b07494dd3a40e4">pixThresholdTo4bpp</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="pixalloc__reg_8c.html#a403607c6ab768f89805d4fa62904488f">nlevels</a>, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> cmapflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a60ad24aeaabd86b3172d67f8c554ea79">pixThresholdOn8bpp</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="pixalloc__reg_8c.html#a403607c6ab768f89805d4fa62904488f">nlevels</a>, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> cmapflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#aaaeb6bde945e04910ae3722eadbff09a">pixThresholdGrayArb</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, const char *edgevals, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> outdepth, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> use_average, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> setblack, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> setwhite)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a81972acff746db6a4da98ede8016b0b6">makeGrayQuantIndexTable</a> (<a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="pixalloc__reg_8c.html#a403607c6ab768f89805d4fa62904488f">nlevels</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a0d31c335238af9a0f70a75497ad7308a">makeGrayQuantTargetTable</a> (<a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="pixalloc__reg_8c.html#a403607c6ab768f89805d4fa62904488f">nlevels</a>, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> depth)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a7803b7a0e3d87efbf7598dd60471e177">makeGrayQuantTableArb</a> (<a class="el" href="struct_numa.html">NUMA</a> *na, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> outdepth, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> **ptab, <a class="el" href="struct_pix_colormap.html">PIXCMAP</a> **pcmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a7e7ea1b723bfa3905822d96454812ff5">makeGrayQuantColormapArb</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *tab, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> outdepth, <a class="el" href="struct_pix_colormap.html">PIXCMAP</a> **pcmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a708dd95f480cdd04749bedfb66101dc4">pixGenerateMaskByBand32</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> refval, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> delm, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> delp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a9ba82604f7479feeeee4656c52316335">pixGenerateMaskByDiscr32</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> refval1, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> refval2, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> distflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#ae5d29a35d86c34b6f4d465e61e720eea">pixGrayQuantFromHisto</a> (<a class="el" href="struct_pix.html">PIX</a> *pixd, <a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pix.html">PIX</a> *pixm, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> minfract, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="overlap__reg_8c.html#a332ff7829674eedb7280f7ea608e11c3">maxsize</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="grayquant_8c.html#a53fdbfca6e8f50c109297eb144cd1f26">pixGrayQuantFromCmap</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *cmap, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> mindepth)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Standard, simple, general grayscale quantization. </p>

<p>Definition in file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="acacc3a64b1f2a391a58ca11a961ac2de"></a><!-- doxytag: member="grayquant.c::numaFillCmapFromHisto" ref="acacc3a64b1f2a391a58ca11a961ac2de" args="(NUMA *na, PIXCMAP *cmap, l_float32 minfract, l_int32 maxsize, l_int32 **plut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> numaFillCmapFromHisto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_numa.html">NUMA</a> *&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *&#160;</td>
          <td class="paramname"><em>cmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>minfract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> **&#160;</td>
          <td class="paramname"><em>plut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#acacc3a64b1f2a391a58ca11a961ac2de">numaFillCmapFromHisto()</a></p>
<p>Input: na (histogram of gray values) cmap (8 bpp cmap, possibly initialized with color value) minfract (minimum fraction of pixels in a set of adjacent histo bins that causes the set to be automatically set aside as a color in the colormap; must be at least 0.01) maxsize (maximum number of adjacent bins allowed to represent a color, regardless of the population of pixels in the bins; must be at least 2) &amp;lut (&lt;return&gt; lookup table from gray value to colormap index) Return: 0 if OK, 1 on error</p>
<p>Notes: (1) This static function must be called from <a class="el" href="grayquant_8c.html#ae5d29a35d86c34b6f4d465e61e720eea">pixGrayQuantFromHisto()</a> </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01690">1690</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="numabasic_8c_source.html#l00738">numaGetIArray()</a>, <a class="el" href="numafunc1_8c_source.html#l00395">numaGetSum()</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00517">pixcmapGetCount()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="compfilter__reg_8c_source.html#l00037">total</a>.</p>

<p>Referenced by <a class="el" href="grayquant_8c_source.html#l01561">pixGrayQuantFromHisto()</a>.</p>

</div>
</div>
<a class="anchor" id="acaa60003b944a27639db5df7f4ea2de4"></a><!-- doxytag: member="grayquant.c::pixDitherToBinary" ref="acaa60003b944a27639db5df7f4ea2de4" args="(PIX *pixs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixDitherToBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#acaa60003b944a27639db5df7f4ea2de4">pixDitherToBinary()</a></p>
<p>Input: pixs Return: pixd (dithered binary), or null on error</p>
<p>The Floyd-Steinberg error diffusion dithering algorithm binarizes an 8 bpp grayscale image to a threshold of 128. If a pixel has a value above 127, it is binarized to white and the excess (below 255) is subtracted from three neighboring pixels in the fractions 3/8 to (i, j+1), 3/8 to (i+1, j) and 1/4 to (i+1,j+1), truncating to 0 if necessary. Likewise, if it the pixel has a value below 128, it is binarized to black and the excess above 0 is added to the neighboring pixels, truncating to 255 if necessary.</p>
<p>This function differs from straight dithering in that it allows clipping of grayscale to 0 or 255 if the values are sufficiently close, without distribution of the excess. This uses default values to specify the range of lower and upper values (near 0 and 255, rsp) that are clipped to black and white without propagating the excess. Not propagating the excess has the effect of reducing the snake patterns in parts of the image that are nearly black or white; however, it also prevents the attempt to reproduce gray for those values.</p>
<p>The implementation is straightforward. It uses a pair of line buffers to avoid changing pixs. It is about 2x faster than the implementation using LUTs. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00123">123</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="pix_8h_source.html#l00741">DEFAULT_CLIP_LOWER_1</a>, <a class="el" href="pix_8h_source.html#l00742">DEFAULT_CLIP_UPPER_1</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="grayquant_8c_source.html#l00153">pixDitherToBinarySpec()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="dithertest_8c_source.html#l00029">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ab4f56a43143491151bee008a0ad33478"></a><!-- doxytag: member="grayquant.c::pixDitherToBinarySpec" ref="ab4f56a43143491151bee008a0ad33478" args="(PIX *pixs, l_int32 lowerclip, l_int32 upperclip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixDitherToBinarySpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>lowerclip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>upperclip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#ab4f56a43143491151bee008a0ad33478">pixDitherToBinarySpec()</a></p>
<p>Input: pixs lowerclip (lower clip distance to black; use 0 for default) upperclip (upper clip distance to white; use 0 for default) Return: pixd (dithered binary), or null on error</p>
<p>Notes: (1) See comments above in <a class="el" href="grayquant_8c.html#acaa60003b944a27639db5df7f4ea2de4">pixDitherToBinary()</a> for details. (2) The input parameters lowerclip and upperclip specify the range of lower and upper values (near 0 and 255, rsp) that are clipped to black and white without propagating the excess. For that reason, lowerclip and upperclip should be small numbers. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00153">153</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="grayquantlow_8c_source.html#l00069">ditherToBinaryLow()</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>.</p>

<p>Referenced by <a class="el" href="grayquant_8c_source.html#l00123">pixDitherToBinary()</a>.</p>

</div>
</div>
<a class="anchor" id="ae860cea63ac0db20d92af73cf17f37c7"></a><!-- doxytag: member="grayquant.c::pixThresholdToBinary" ref="ae860cea63ac0db20d92af73cf17f37c7" args="(PIX *pixs, l_int32 thresh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixThresholdToBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#ae860cea63ac0db20d92af73cf17f37c7">pixThresholdToBinary()</a></p>
<p>Input: pixs (4 or 8 bpp) threshold value Return: pixd (1 bpp), or null on error</p>
<p>Notes: (1) If the source pixel is less than the threshold value, the dest will be 1; otherwise, it will be 0 </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00217">217</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>, and <a class="el" href="grayquantlow_8c_source.html#l00243">thresholdToBinaryLow()</a>.</p>

<p>Referenced by <a class="el" href="threshnorm__reg_8c_source.html#l00065">AddTestSet()</a>, <a class="el" href="convertfiles_8c_source.html#l00052">convertFilesTo1bpp()</a>, <a class="el" href="adaptnorm__reg_8c_source.html#l00026">main()</a>, <a class="el" href="convolve_8c_source.html#l01098">pixBlockrank()</a>, <a class="el" href="colorcontent_8c_source.html#l00766">pixColorsForQuantization()</a>, <a class="el" href="pixconv_8c_source.html#l02194">pixConvertTo1()</a>, <a class="el" href="adaptmap_8c_source.html#l00764">pixGetBackgroundGrayMap()</a>, <a class="el" href="adaptmap_8c_source.html#l00939">pixGetBackgroundRGBMap()</a>, <a class="el" href="readbarcode_8c_source.html#l00375">pixLocateBarcodes()</a>, <a class="el" href="binarize_8c_source.html#l00323">pixMaskedThreshOnBackgroundNorm()</a>, <a class="el" href="binarize_8c_source.html#l00114">pixOtsuAdaptiveThreshold()</a>, <a class="el" href="rotate_8c_source.html#l00424">pixRotateBinaryNice()</a>, <a class="el" href="seedfill_8c_source.html#l01037">pixSeedspread()</a>, <a class="el" href="pix3_8c_source.html#l00903">pixSetUnderTransparency()</a>, <a class="el" href="pixconv_8c_source.html#l00157">pixThreshold8()</a>, <a class="el" href="pix4_8c_source.html#l02539">pixThresholdForFgBg()</a>, <a class="el" href="adaptmap_8c_source.html#l02263">pixThresholdSpreadNorm()</a>, and <a class="el" href="psio1_8c_source.html#l00564">pixWriteSegmentedPageToPS()</a>.</p>

</div>
</div>
<a class="anchor" id="ab3cd276d0ba9aabdcc7a2165724aab7b"></a><!-- doxytag: member="grayquant.c::pixVarThresholdToBinary" ref="ab3cd276d0ba9aabdcc7a2165724aab7b" args="(PIX *pixs, PIX *pixg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixVarThresholdToBinary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#ab3cd276d0ba9aabdcc7a2165724aab7b">pixVarThresholdToBinary()</a></p>
<p>Input: pixs (8 bpp) pixg (8 bpp; contains threshold values for each pixel) Return: pixd (1 bpp), or null on error</p>
<p>Notes: (1) If the pixel in pixs is less than the corresponding pixel in pixg, the dest will be 1; otherwise it will be 0. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00275">275</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l00680">pixSizesEqual()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="arrayaccess_8h_source.html#l00063">SET_DATA_BIT</a>.</p>

<p>Referenced by <a class="el" href="adaptmap_8c_source.html#l02263">pixThresholdSpreadNorm()</a>.</p>

</div>
</div>
<a class="anchor" id="abf3d8b88984f004aae26e0b46db7b000"></a><!-- doxytag: member="grayquant.c::pixDitherToBinaryLUT" ref="abf3d8b88984f004aae26e0b46db7b000" args="(PIX *pixs, l_int32 lowerclip, l_int32 upperclip)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixDitherToBinaryLUT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>lowerclip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>upperclip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#abf3d8b88984f004aae26e0b46db7b000">pixDitherToBinaryLUT()</a></p>
<p>Input: pixs lowerclip (lower clip distance to black; use -1 for default) upperclip (upper clip distance to white; use -1 for default) Return: pixd (dithered binary), or null on error</p>
<p>This implementation is deprecated. You should use <a class="el" href="grayquant_8c.html#acaa60003b944a27639db5df7f4ea2de4">pixDitherToBinary()</a>.</p>
<p>See comments in <a class="el" href="grayquant_8c.html#acaa60003b944a27639db5df7f4ea2de4">pixDitherToBinary()</a></p>
<p>This implementation additionally uses three lookup tables to generate the output pixel value and the excess or deficit carried over to the neighboring pixels. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00337">337</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="pix_8h_source.html#l00741">DEFAULT_CLIP_LOWER_1</a>, <a class="el" href="pix_8h_source.html#l00742">DEFAULT_CLIP_UPPER_1</a>, <a class="el" href="grayquantlow_8c_source.html#l00402">ditherToBinaryLUTLow()</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="grayquantlow_8c_source.html#l00542">make8To1DitherTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>.</p>

</div>
</div>
<a class="anchor" id="a7b1ce9bba23ca636b5a375f82c5d9759"></a><!-- doxytag: member="grayquant.c::pixGenerateMaskByValue" ref="a7b1ce9bba23ca636b5a375f82c5d9759" args="(PIX *pixs, l_int32 val, l_int32 usecmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixGenerateMaskByValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>usecmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a7b1ce9bba23ca636b5a375f82c5d9759">pixGenerateMaskByValue()</a></p>
<p>Input: pixs (4 or 8 bpp, or colormapped) val (of pixels for which we set 1 in dest) usecmap (1 to retain cmap values; 0 to convert to gray) Return: pixd (1 bpp), or null on error</p>
<p>Notes: (1)  is the gray value of the pixels that we are selecting. (2) If pixs is colormapped,  determines if the colormap values are used, or if the colormap is removed to gray and the gray values are used. For the latter, it generates an approximate grayscale value for each pixel, and then looks for gray pixels with the value . </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00413">413</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00097">GET_DATA_QBIT</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l00440">pixClone()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>, and <a class="el" href="arrayaccess_8h_source.html#l00063">SET_DATA_BIT</a>.</p>

<p>Referenced by <a class="el" href="colorseg_8c_source.html#l00466">pixColorSegmentClean()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cb4b4a02dd87f6b6577af59acdb13f4"></a><!-- doxytag: member="grayquant.c::pixGenerateMaskByBand" ref="a8cb4b4a02dd87f6b6577af59acdb13f4" args="(PIX *pixs, l_int32 lower, l_int32 upper, l_int32 inband, l_int32 usecmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixGenerateMaskByBand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>inband</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>usecmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a8cb4b4a02dd87f6b6577af59acdb13f4">pixGenerateMaskByBand()</a></p>
<p>Input: pixs (4 or 8 bpp, or colormapped) lower, upper (two pixel values from which a range, either between (inband) or outside of (!inband), determines which pixels in pixs cause us to set a 1 in the dest mask) inband (1 for finding pixels in [lower, upper]; 0 for finding pixels in [0, lower) union (upper, 255]) usecmap (1 to retain cmap values; 0 to convert to gray) Return: pixd (1 bpp), or null on error</p>
<p>Notes: (1) Generates a 1 bpp mask pixd, the same size as pixs, where the fg pixels in the mask are those either within the specified band (for inband == 1) or outside the specified band (for inband == 0). (2) If pixs is colormapped,  determines if the colormap values are used, or if the colormap is removed to gray and the gray values are used. For the latter, it generates an approximate grayscale value for each pixel, and then looks for gray pixels with the value . </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00494">494</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00097">GET_DATA_QBIT</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l00440">pixClone()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>, and <a class="el" href="arrayaccess_8h_source.html#l00063">SET_DATA_BIT</a>.</p>

</div>
</div>
<a class="anchor" id="a6b38a8f5e0d12b077cb002545d3d14eb"></a><!-- doxytag: member="grayquant.c::pixDitherTo2bpp" ref="a6b38a8f5e0d12b077cb002545d3d14eb" args="(PIX *pixs, l_int32 cmapflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixDitherTo2bpp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>cmapflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a6b38a8f5e0d12b077cb002545d3d14eb">pixDitherTo2bpp()</a></p>
<p>Input: pixs (8 bpp) cmapflag (1 to generate a colormap) Return: pixd (dithered 2 bpp), or null on error</p>
<p>An analog of the Floyd-Steinberg error diffusion dithering algorithm is used to "dibitize" an 8 bpp grayscale image to 2 bpp, using equally spaced gray values of 0, 85, 170, and 255, which are served by thresholds of 43, 128 and 213. If cmapflag == 1, the colormap values are set to 0, 85, 170 and 255. If a pixel has a value between 0 and 42, it is dibitized to 0, and the excess (above 0) is added to the three neighboring pixels, in the fractions 3/8 to (i, j+1), 3/8 to (i+1, j) and 1/4 to (i+1, j+1), truncating to 255 if necessary. If a pixel has a value between 43 and 127, it is dibitized to 1, and the excess (above 85) is added to the three neighboring pixels as before. If the value is below 85, the excess is subtracted. With a value between 128 and 212, it is dibitized to 2, with the excess on either side of 170 distributed as before. Finally, with a value between 213 and 255, it is dibitized to 3, with the excess (below 255) subtracted from the neighbors. We always truncate to 0 or 255. The details can be seen in the lookup table generation.</p>
<p>This function differs from straight dithering in that it allows clipping of grayscale to 0 or 255 if the values are sufficiently close, without distribution of the excess. This uses default values (from <a class="el" href="pix_8h.html" title="Basic file defining image and image-related structs (Pix, PixColormap, Pixa, Pixaa, Box, Boxa, Boxaa, Pta, Ptaa, Pixacc, PixTiling, FPix, DPix, PixComp, PixaComp), along with enums for many operations.">pix.h</a>) to specify the range of lower and upper values (near 0 and 255, rsp) that are clipped to black and white without propagating the excess. Not propagating the excess has the effect of reducing the snake patterns in parts of the image that are nearly black or white; however, it also prevents any attempt to reproduce gray for those values.</p>
<p>The implementation uses 3 lookup tables for simplicity, and a pair of line buffers to avoid modifying pixs. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00601">601</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="pix_8h_source.html#l00743">DEFAULT_CLIP_LOWER_2</a>, <a class="el" href="pix_8h_source.html#l00744">DEFAULT_CLIP_UPPER_2</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="grayquant_8c_source.html#l00633">pixDitherTo2bppSpec()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="adaptnorm__reg_8c_source.html#l00026">main()</a>.</p>

</div>
</div>
<a class="anchor" id="ab95548869f5ef1cedca1974bec7b6b5d"></a><!-- doxytag: member="grayquant.c::pixDitherTo2bppSpec" ref="ab95548869f5ef1cedca1974bec7b6b5d" args="(PIX *pixs, l_int32 lowerclip, l_int32 upperclip, l_int32 cmapflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixDitherTo2bppSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>lowerclip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>upperclip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>cmapflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#ab95548869f5ef1cedca1974bec7b6b5d">pixDitherTo2bppSpec()</a></p>
<p>Input: pixs (8 bpp) lowerclip (lower clip distance to black; use 0 for default) upperclip (upper clip distance to white; use 0 for default) cmapflag (1 to generate a colormap) Return: pixd (dithered 2 bpp), or null on error</p>
<p>Notes: (1) See comments above in <a class="el" href="grayquant_8c.html#a6b38a8f5e0d12b077cb002545d3d14eb">pixDitherTo2bpp()</a> for details. (2) The input parameters lowerclip and upperclip specify the range of lower and upper values (near 0 and 255, rsp) that are clipped to black and white without propagating the excess. For that reason, lowerclip and upperclip should be small numbers. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00633">633</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="grayquantlow_8c_source.html#l00612">ditherTo2bppLow()</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="grayquantlow_8c_source.html#l00753">make8To2DitherTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00177">pixcmapCreateLinear()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>.</p>

<p>Referenced by <a class="el" href="grayquant_8c_source.html#l00601">pixDitherTo2bpp()</a>.</p>

</div>
</div>
<a class="anchor" id="a28f0a87372b62df5b1480f58136823d1"></a><!-- doxytag: member="grayquant.c::pixThresholdTo2bpp" ref="a28f0a87372b62df5b1480f58136823d1" args="(PIX *pixs, l_int32 nlevels, l_int32 cmapflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixThresholdTo2bpp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>cmapflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a28f0a87372b62df5b1480f58136823d1">pixThresholdTo2bpp()</a></p>
<p>Input: pixs (8 bpp) nlevels (equally spaced; must be between 2 and 4) cmapflag (1 to build colormap; 0 otherwise) Return: pixd (2 bpp, optionally with colormap), or null on error</p>
<p>Notes: (1) Valid values for nlevels is the set {2, 3, 4}. (2) Any colormap on the input pixs is removed to 8 bpp grayscale. (3) This function is typically invoked with cmapflag == 1. In the situation where no colormap is desired, nlevels is ignored and pixs is thresholded to 4 levels. (4) The target output colors are equally spaced, with the darkest at 0 and the lightest at 255. The thresholds are chosen halfway between adjacent output values. A table is built that specifies the mapping from src to dest. (5) If cmapflag == 1, a colormap of size 'nlevels' is made, and the pixel values in pixs are replaced by their appropriate color indices. The number of holdouts, 4 - nlevels, will be between 0 and 2. (6) If you don't want the thresholding to be equally spaced, either first transform the 8 bpp src using <a class="el" href="enhance_8c.html#a92332d1787e616ac37e3a562b247f1bd">pixGammaTRC()</a>. or, if cmapflag == 1, after calling this function you can use <a class="el" href="colormap_8c.html#a17a44e20b001ad0b66505544c044072e">pixcmapResetColor()</a> to change any individual colors. (7) If a colormap is generated, it will specify (to display programs) exactly how each level is to be represented in RGB space. When representing text, 3 levels is far better than 2 because of the antialiasing of the single gray level, and 4 levels (black, white and 2 gray levels) is getting close to the perceptual quality of a (nearly continuous) grayscale image. With 2 bpp, you can set up a colormap and allocate from 2 to 4 levels to represent antialiased text. Any left over colormap entries can be used for coloring regions. For the same number of levels, the file size of a 2 bpp image is about 10% smaller than that of a 4 bpp result for the same number of levels. For both 2 bpp and 4 bpp, using 4 levels you get compression far better than that of jpeg, because the quantization to 4 levels will remove the jpeg ringing in the background near character edges. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00742">742</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="grayquant_8c_source.html#l01112">makeGrayQuantIndexTable()</a>, <a class="el" href="grayquant_8c_source.html#l01162">makeGrayQuantTargetTable()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00177">pixcmapCreateLinear()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>, and <a class="el" href="grayquantlow_8c_source.html#l00844">thresholdTo2bppLow()</a>.</p>

<p>Referenced by <a class="el" href="conversion__reg_8c_source.html#l00027">main()</a>, and <a class="el" href="pixconv_8c_source.html#l00157">pixThreshold8()</a>.</p>

</div>
</div>
<a class="anchor" id="a3ceb912e2683196af6b07494dd3a40e4"></a><!-- doxytag: member="grayquant.c::pixThresholdTo4bpp" ref="a3ceb912e2683196af6b07494dd3a40e4" args="(PIX *pixs, l_int32 nlevels, l_int32 cmapflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixThresholdTo4bpp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>cmapflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a3ceb912e2683196af6b07494dd3a40e4">pixThresholdTo4bpp()</a></p>
<p>Input: pixs (8 bpp, can have colormap) nlevels (equally spaced; must be between 2 and 16) cmapflag (1 to build colormap; 0 otherwise) Return: pixd (4 bpp, optionally with colormap), or null on error</p>
<p>Notes: (1) Valid values for nlevels is the set {2, ... 16}. (2) Any colormap on the input pixs is removed to 8 bpp grayscale. (3) This function is typically invoked with cmapflag == 1. In the situation where no colormap is desired, nlevels is ignored and pixs is thresholded to 16 levels. (4) The target output colors are equally spaced, with the darkest at 0 and the lightest at 255. The thresholds are chosen halfway between adjacent output values. A table is built that specifies the mapping from src to dest. (5) If cmapflag == 1, a colormap of size 'nlevels' is made, and the pixel values in pixs are replaced by their appropriate color indices. The number of holdouts, 16 - nlevels, will be between 0 and 14. (6) If you don't want the thresholding to be equally spaced, either first transform the 8 bpp src using <a class="el" href="enhance_8c.html#a92332d1787e616ac37e3a562b247f1bd">pixGammaTRC()</a>. or, if cmapflag == 1, after calling this function you can use <a class="el" href="colormap_8c.html#a17a44e20b001ad0b66505544c044072e">pixcmapResetColor()</a> to change any individual colors. (7) If a colormap is generated, it will specify, to display programs, exactly how each level is to be represented in RGB space. When representing text, 3 levels is far better than 2 because of the antialiasing of the single gray level, and 4 levels (black, white and 2 gray levels) is getting close to the perceptual quality of a (nearly continuous) grayscale image. Therefore, with 4 bpp, you can set up a colormap, allocate a relatively small fraction of the 16 possible values to represent antialiased text, and use the other colormap entries for other things, such as coloring text or background. Two other reasons for using a small number of gray values for antialiased text are (1) PNG compression gets worse as the number of levels that are used is increased, and (2) using a small number of levels will filter out most of the jpeg ringing that is typically introduced near sharp edges of text. This filtering is partly responsible for the improved compression. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00840">840</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="grayquant_8c_source.html#l01112">makeGrayQuantIndexTable()</a>, <a class="el" href="grayquant_8c_source.html#l01162">makeGrayQuantTargetTable()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00177">pixcmapCreateLinear()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>, and <a class="el" href="grayquantlow_8c_source.html#l00889">thresholdTo4bppLow()</a>.</p>

<p>Referenced by <a class="el" href="adaptnorm__reg_8c_source.html#l00026">main()</a>, <a class="el" href="morphapp_8c_source.html#l00750">pixDisplayMatchedPattern()</a>, <a class="el" href="pixconv_8c_source.html#l01127">pixQuantizeIfFewColors()</a>, and <a class="el" href="pixconv_8c_source.html#l00157">pixThreshold8()</a>.</p>

</div>
</div>
<a class="anchor" id="a60ad24aeaabd86b3172d67f8c554ea79"></a><!-- doxytag: member="grayquant.c::pixThresholdOn8bpp" ref="a60ad24aeaabd86b3172d67f8c554ea79" args="(PIX *pixs, l_int32 nlevels, l_int32 cmapflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixThresholdOn8bpp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>cmapflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a60ad24aeaabd86b3172d67f8c554ea79">pixThresholdOn8bpp()</a></p>
<p>Input: pixs (8 bpp, can have colormap) nlevels (equally spaced; must be between 2 and 256) cmapflag (1 to build colormap; 0 otherwise) Return: pixd (8 bpp, optionally with colormap), or null on error</p>
<p>Notes: (1) Valid values for nlevels is the set {2,...,256}. (2) Any colormap on the input pixs is removed to 8 bpp grayscale. (3) If cmapflag == 1, a colormap of size 'nlevels' is made, and the pixel values in pixs are replaced by their appropriate color indices. Otherwise, the pixel values are the actual thresholded (i.e., quantized) grayscale values. (4) If you don't want the thresholding to be equally spaced, first transform the input 8 bpp src using <a class="el" href="enhance_8c.html#a92332d1787e616ac37e3a562b247f1bd">pixGammaTRC()</a>. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l00912">912</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="grayquant_8c_source.html#l01112">makeGrayQuantIndexTable()</a>, <a class="el" href="grayquant_8c_source.html#l01162">makeGrayQuantTargetTable()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00177">pixcmapCreateLinear()</a>, <a class="el" href="pix1_8c_source.html#l00548">pixCopy()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>, and <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>.</p>

<p>Referenced by <a class="el" href="grayquant__reg_8c_source.html#l00031">main()</a>, <a class="el" href="colorquant2_8c_source.html#l00736">pixFewColorsMedianCutQuantMixed()</a>, <a class="el" href="colorquant2_8c_source.html#l00562">pixMedianCutQuantMixed()</a>, <a class="el" href="pixconv_8c_source.html#l01127">pixQuantizeIfFewColors()</a>, <a class="el" href="pixconv_8c_source.html#l00157">pixThreshold8()</a>, and <a class="el" href="pdfiotest_8c_source.html#l00432">QuantizeNonImageRegion()</a>.</p>

</div>
</div>
<a class="anchor" id="aaaeb6bde945e04910ae3722eadbff09a"></a><!-- doxytag: member="grayquant.c::pixThresholdGrayArb" ref="aaaeb6bde945e04910ae3722eadbff09a" args="(PIX *pixs, const char *edgevals, l_int32 outdepth, l_int32 use_average, l_int32 setblack, l_int32 setwhite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixThresholdGrayArb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>edgevals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>outdepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>use_average</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>setblack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>setwhite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#aaaeb6bde945e04910ae3722eadbff09a">pixThresholdGrayArb()</a></p>
<p>Input: pixs (8 bpp grayscale; can have colormap) edgevals (string giving edge value of each bin) outdepth (0, 2, 4 or 8 bpp; 0 is default for min depth) use_average (1 if use the average pixel value in colormap) setblack (1 if darkest color is set to black) setwhite (1 if lightest color is set to white) Return: pixd (2, 4 or 8 bpp quantized image with colormap), or null on error</p>
<p>Notes: (1) This function allows exact specification of the quantization bins. The string  is a space-separated set of values specifying the dividing points between output quantization bins. These threshold values are assigned to the bin with higher values, so that each of them is the smallest value in their bin. (2) The output image (pixd) depth is specified by . The number of bins is the number of edgevals + 1. The relation between outdepth and the number of bins is: outdepth = 2 nbins &lt;= 4 outdepth = 4 nbins &lt;= 16 outdepth = 8 nbins &lt;= 256 With  == 0, the minimum required depth for the given number of bins is used. The output pixd has a colormap. (3) The last 3 args determine the specific values that go into the colormap. (4) For :</p>
<ul>
<li>if TRUE, the average value of pixels falling in the bin is chosen as the representative gray value. Otherwise,</li>
<li>if FALSE, the central value of each bin is chosen as the representative value. The colormap holds the representative value. (5) For , if TRUE the darkest color is set to (0,0,0). (6) For , if TRUE the lightest color is set to (255,255,255). (7) An alternative to using this function to quantize to unequally-spaced bins is to first transform the 8 bpp pixs using <a class="el" href="enhance_8c.html#a92332d1787e616ac37e3a562b247f1bd">pixGammaTRC()</a>, and follow this with <a class="el" href="grayquant_8c.html#a3ceb912e2683196af6b07494dd3a40e4">pixThresholdTo4bpp()</a>. </li>
</ul>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01009">1009</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="pix_8h_source.html#l00609">L_SORT_INCREASING</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="grayquant_8c_source.html#l01287">makeGrayQuantColormapArb()</a>, <a class="el" href="grayquant_8c_source.html#l01216">makeGrayQuantTableArb()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="numabasic_8c_source.html#l00292">numaDestroy()</a>, <a class="el" href="numabasic_8c_source.html#l00557">numaGetCount()</a>, <a class="el" href="numafunc1_8c_source.html#l02056">numaSort()</a>, <a class="el" href="kernel_8c_source.html#l00953">parseStringForNumbers()</a>, <a class="el" href="colormap_8c_source.html#l00238">pixcmapDestroy()</a>, <a class="el" href="colormap_8c_source.html#l00486">pixcmapSetBlackAndWhite()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="pix_8h_source.html#l00179">REMOVE_CMAP_TO_GRAYSCALE</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="grayquantlow_8c_source.html#l00844">thresholdTo2bppLow()</a>, and <a class="el" href="grayquantlow_8c_source.html#l00889">thresholdTo4bppLow()</a>.</p>

<p>Referenced by <a class="el" href="grayquant__reg_8c_source.html#l00031">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a81972acff746db6a4da98ede8016b0b6"></a><!-- doxytag: member="grayquant.c::makeGrayQuantIndexTable" ref="a81972acff746db6a4da98ede8016b0b6" args="(l_int32 nlevels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>* makeGrayQuantIndexTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>nlevels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a81972acff746db6a4da98ede8016b0b6">makeGrayQuantIndexTable()</a></p>
<p>Input: nlevels (number of output levels) Return: table (maps input gray level to colormap index, or null on error) Notes: (1) 'nlevels' is some number between 2 and 256 (typically 8 or less). (2) The table is typically used for quantizing 2, 4 and 8 bpp grayscale src pix, and generating a colormapped dest pix. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01112">1112</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pixalloc__reg_8c_source.html#l00041">nlevels</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l02524">pixOctcubeQuantMixedWithGray()</a>, <a class="el" href="grayquant_8c_source.html#l00912">pixThresholdOn8bpp()</a>, <a class="el" href="grayquant_8c_source.html#l00742">pixThresholdTo2bpp()</a>, and <a class="el" href="grayquant_8c_source.html#l00840">pixThresholdTo4bpp()</a>.</p>

</div>
</div>
<a class="anchor" id="a0d31c335238af9a0f70a75497ad7308a"></a><!-- doxytag: member="grayquant.c::makeGrayQuantTargetTable" ref="a0d31c335238af9a0f70a75497ad7308a" args="(l_int32 nlevels, l_int32 depth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>* makeGrayQuantTargetTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a0d31c335238af9a0f70a75497ad7308a">makeGrayQuantTargetTable()</a></p>
<p>Input: nlevels (number of output levels) depth (of dest pix, in bpp; 2, 4 or 8 bpp) Return: table (maps input gray level to thresholded gray level, or null on error)</p>
<p>Notes: (1) nlevels is some number between 2 and 2^(depth) (2) The table is used in two similar ways:</p>
<ul>
<li>for 8 bpp, it quantizes to a given number of target levels</li>
<li>for 2 and 4 bpp, it thresholds to appropriate target values that will use the full dynamic range of the dest pix. (3) For depth = 8, the number of thresholds chosen is ('nlevels' - 1), and the 'nlevels' values stored in the table are at the two at the extreme ends, (0, 255), plus plus ('nlevels' - 2) values chosen at equal intervals between. For example, for depth = 8 and 'nlevels' = 3, the two threshold values are 3f and bf, and the three target pixel values are 0, 7f and ff. (4) For depth &lt; 8, we ignore nlevels, and always use the maximum number of levels, which is 2^(depth). If you want nlevels &lt; the maximum number, you should always use a colormap. </li>
</ul>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01162">1162</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pixalloc__reg_8c_source.html#l00041">nlevels</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="grayquant_8c_source.html#l00912">pixThresholdOn8bpp()</a>, <a class="el" href="grayquant_8c_source.html#l00742">pixThresholdTo2bpp()</a>, and <a class="el" href="grayquant_8c_source.html#l00840">pixThresholdTo4bpp()</a>.</p>

</div>
</div>
<a class="anchor" id="a7803b7a0e3d87efbf7598dd60471e177"></a><!-- doxytag: member="grayquant.c::makeGrayQuantTableArb" ref="a7803b7a0e3d87efbf7598dd60471e177" args="(NUMA *na, l_int32 outdepth, l_int32 **ptab, PIXCMAP **pcmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> makeGrayQuantTableArb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_numa.html">NUMA</a> *&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>outdepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> **&#160;</td>
          <td class="paramname"><em>ptab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix_colormap.html">PIXCMAP</a> **&#160;</td>
          <td class="paramname"><em>pcmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a7803b7a0e3d87efbf7598dd60471e177">makeGrayQuantTableArb()</a></p>
<p>Input: na (numa of bin boundaries) outdepth (of colormap: 1, 2, 4 or 8) &amp;tab (&lt;return&gt; table mapping input gray level to cmap index) &amp;cmap (&lt;return&gt; colormap) Return: 0 if OK, 1 on error</p>
<p>Notes: (1) The number of bins is the count of  + 1. (2) The bin boundaries in na must be sorted in increasing order. (3) The table is an inverse colormap: it maps input gray level to colormap index (the bin number). (4) The colormap generated here has quantized values at the center of each bin. If you want to use the average gray value of pixels within the bin, discard the colormap and compute it using <a class="el" href="grayquant_8c.html#a7e7ea1b723bfa3905822d96454812ff5">makeGrayQuantColormapArb()</a>. (5) Returns an error if there are not enough levels in the output colormap for the number of bins. The number of bins must not exceed 2^outdepth. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01216">1216</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="numabasic_8c_source.html#l00557">numaGetCount()</a>, <a class="el" href="numabasic_8c_source.html#l00647">numaGetIValue()</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="grayquant_8c_source.html#l01009">pixThresholdGrayArb()</a>.</p>

</div>
</div>
<a class="anchor" id="a7e7ea1b723bfa3905822d96454812ff5"></a><!-- doxytag: member="grayquant.c::makeGrayQuantColormapArb" ref="a7e7ea1b723bfa3905822d96454812ff5" args="(PIX *pixs, l_int32 *tab, l_int32 outdepth, PIXCMAP **pcmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> makeGrayQuantColormapArb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>outdepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix_colormap.html">PIXCMAP</a> **&#160;</td>
          <td class="paramname"><em>pcmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a7e7ea1b723bfa3905822d96454812ff5">makeGrayQuantColormapArb()</a></p>
<p>Input: pixs (8 bpp) tab (table mapping input gray level to cmap index) outdepth (of colormap: 1, 2, 4 or 8) &amp;cmap (&lt;return&gt; colormap) Return: 0 if OK, 1 on error</p>
<p>Notes: (1) The table is a 256-entry inverse colormap: it maps input gray level to colormap index (the bin number). It is computed using <a class="el" href="grayquant_8c.html#a7803b7a0e3d87efbf7598dd60471e177">makeGrayQuantTableArb()</a>. (2) The colormap generated here has quantized values at the average gray value of the pixels that are in each bin. (3) Returns an error if there are not enough levels in the output colormap for the number of bins. The number of bins must not exceed 2^outdepth. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01287">1287</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="environ_8h_source.html#l00155">L_MAX</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="grayquant_8c_source.html#l01009">pixThresholdGrayArb()</a>.</p>

</div>
</div>
<a class="anchor" id="a708dd95f480cdd04749bedfb66101dc4"></a><!-- doxytag: member="grayquant.c::pixGenerateMaskByBand32" ref="a708dd95f480cdd04749bedfb66101dc4" args="(PIX *pixs, l_uint32 refval, l_int32 delm, l_int32 delp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixGenerateMaskByBand32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a>&#160;</td>
          <td class="paramname"><em>refval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>delm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>delp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a708dd95f480cdd04749bedfb66101dc4">pixGenerateMaskByBand32()</a></p>
<p>Input: pixs (32 bpp) refval (reference rgb value) delm (max amount below the ref value for any component) delp (max amount above the ref value for any component) Return: pixd (1 bpp), or null on error</p>
<p>Notes: (1) Generates a 1 bpp mask pixd, the same size as pixs, where the fg pixels in the mask are those where each component is within -delm to +delp of the reference value. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01379">1379</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="pix_8h_source.html#l00153">L_BLUE_SHIFT</a>, <a class="el" href="pix_8h_source.html#l00151">L_GREEN_SHIFT</a>, <a class="el" href="pix_8h_source.html#l00149">L_RED_SHIFT</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="arrayaccess_8h_source.html#l00063">SET_DATA_BIT</a>.</p>

</div>
</div>
<a class="anchor" id="a9ba82604f7479feeeee4656c52316335"></a><!-- doxytag: member="grayquant.c::pixGenerateMaskByDiscr32" ref="a9ba82604f7479feeeee4656c52316335" args="(PIX *pixs, l_uint32 refval1, l_uint32 refval2, l_int32 distflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixGenerateMaskByDiscr32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a>&#160;</td>
          <td class="paramname"><em>refval1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a>&#160;</td>
          <td class="paramname"><em>refval2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>distflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a9ba82604f7479feeeee4656c52316335">pixGenerateMaskByDiscr32()</a></p>
<p>Input: pixs (32 bpp) refval1 (reference rgb value) refval2 (reference rgb value) distflag (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE) Return: pixd (1 bpp), or null on error</p>
<p>Notes: (1) Generates a 1 bpp mask pixd, the same size as pixs, where the fg pixels in the mask are those where the pixel in pixs is "closer" to refval1 than to refval2. (2) "Closer" can be defined in several ways, such as:</p>
<ul>
<li>manhattan distance (L1)</li>
<li>euclidean distance (L2)</li>
<li>majority vote of the individual components Here, we have a choice of L1 or L2. </li>
</ul>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01449">1449</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00159">L_ABS</a>, <a class="el" href="pix_8h_source.html#l00753">L_EUCLIDEAN_DISTANCE</a>, <a class="el" href="pix_8h_source.html#l00752">L_MANHATTAN_DISTANCE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="arrayaccess_8h_source.html#l00063">SET_DATA_BIT</a>.</p>

</div>
</div>
<a class="anchor" id="ae5d29a35d86c34b6f4d465e61e720eea"></a><!-- doxytag: member="grayquant.c::pixGrayQuantFromHisto" ref="ae5d29a35d86c34b6f4d465e61e720eea" args="(PIX *pixd, PIX *pixs, PIX *pixm, l_float32 minfract, l_int32 maxsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixGrayQuantFromHisto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>minfract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#ae5d29a35d86c34b6f4d465e61e720eea">pixGrayQuantFromHisto()</a></p>
<p>Input: pixd (&lt;optional&gt; quantized pix with cmap; can be null) pixs (8 bpp gray input pix; not cmapped) pixm (&lt;optional&gt; mask over pixels in pixs to quantize) minfract (minimum fraction of pixels in a set of adjacent histo bins that causes the set to be automatically set aside as a color in the colormap; must be at least 0.01) maxsize (maximum number of adjacent bins allowed to represent a color, regardless of the population of pixels in the bins; must be at least 2) Return: pixd (8 bpp, cmapped), or null on error</p>
<p>Notes: (1) This is useful for quantizing images with relatively few colors, but which may have both color and gray pixels. If there are color pixels, it is assumed that an input rgb image has been color quantized first so that:</p>
<ul>
<li>pixd has a colormap describing the color pixels</li>
<li>pixm is a mask over the non-color pixels in pixd</li>
<li>the colormap in pixd, and the color pixels in pixd, have been repacked to go from 0 to n-1 (n colors) If there are no color pixels, pixd and pixm are both null, and all pixels in pixs are quantized to gray. (2) A 256-entry histogram is built of the gray values in pixs. If pixm exists, the pixels contributing to the histogram are restricted to the fg of pixm. A colormap and LUT are generated from this histogram. We break up the array into a set of intervals, each one constituting a color in the colormap: An interval is identified by summing histogram bins until either the sum equals or exceeds the  of the total number of pixels, or the span itself equals or exceeds . The color of each bin is always an average of the pixels that constitute it. (3) Note that we do not specify the number of gray colors in the colormap. Instead, we specify two parameters that describe the accuracy of the color assignments; this and the actual image determine the number of resulting colors. (4) If a mask exists and it is not the same size as pixs, make a new mask the same size as pixs, with the original mask aligned at the UL corners. Set all additional pixels in the (larger) new mask set to 1, causing those pixels in pixd to be set as gray. (5) We estimate the total number of colors (color plus gray); if it exceeds 255, return null. </li>
</ul>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01561">1561</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00060">GET_DATA_BIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="environ_8h_source.html#l00253">L_ERROR</a>, <a class="el" href="environ_8h_source.html#l00255">L_ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="numabasic_8c_source.html#l00292">numaDestroy()</a>, <a class="el" href="grayquant_8c_source.html#l01690">numaFillCmapFromHisto()</a>, <a class="el" href="pix_8h_source.html#l00247">PIX_SET</a>, <a class="el" href="pix_8h_source.html#l00243">PIX_SRC</a>, <a class="el" href="pix1_8c_source.html#l00440">pixClone()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="colormap_8c_source.html#l00517">pixcmapGetCount()</a>, <a class="el" href="pix1_8c_source.html#l00296">pixCreateNoInit()</a>, <a class="el" href="pix1_8c_source.html#l00328">pixCreateTemplate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix4_8c_source.html#l00186">pixGetGrayHistogramMasked()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="rop_8c_source.html#l00180">pixRasterop()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l03219">pixFewColorsOctcubeQuantMixed()</a>.</p>

</div>
</div>
<a class="anchor" id="a53fdbfca6e8f50c109297eb144cd1f26"></a><!-- doxytag: member="grayquant.c::pixGrayQuantFromCmap" ref="a53fdbfca6e8f50c109297eb144cd1f26" args="(PIX *pixs, PIXCMAP *cmap, l_int32 mindepth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixGrayQuantFromCmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *&#160;</td>
          <td class="paramname"><em>cmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>mindepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="grayquant_8c.html#a53fdbfca6e8f50c109297eb144cd1f26">pixGrayQuantFromCmap()</a></p>
<p>Input: pixs (8 bpp grayscale without cmap) cmap (to quantize to; of dest pix) mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp) Return: pixd (2, 4 or 8 bpp, colormapped), or null on error</p>
<p>Notes: (1) In use, pixs is an 8 bpp grayscale image without a colormap. If there is an existing colormap, a warning is issued and a copy of the input pixs is returned. </p>

<p>Definition at line <a class="el" href="grayquant_8c_source.html#l01780">1780</a> of file <a class="el" href="grayquant_8c_source.html">grayquant.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="environ_8h_source.html#l00155">L_MAX</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l01162">pixcmapColorToGray()</a>, <a class="el" href="colormap_8c_source.html#l00207">pixcmapCopy()</a>, <a class="el" href="colormap_8c_source.html#l00575">pixcmapGetMinDepth()</a>, <a class="el" href="colormap_8c_source.html#l00965">pixcmapGetNearestGrayIndex()</a>, <a class="el" href="colormap_8c_source.html#l00777">pixcmapHasColor()</a>, <a class="el" href="pix1_8c_source.html#l00548">pixCopy()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00083">SET_DATA_DIBIT</a>, and <a class="el" href="arrayaccess_8h_source.html#l00100">SET_DATA_QBIT</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l03406">pixQuantFromCmap()</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="grayquant_8c.html">grayquant.c</a>      </li>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
