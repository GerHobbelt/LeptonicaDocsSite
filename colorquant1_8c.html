<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Leptonica: src/colorquant1.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="moller52-tiny.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Leptonica&#160;<span id="projectnumber">1.68</span></div>
   <div id="projectbrief">C Image Processing Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('colorquant1_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>colorquant1.c File Reference</h1>  </div>
</div>
<div class="contents">

<p>Octcube color quantization.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="allheaders_8h_source.html">allheaders.h</a>&quot;</code><br/>
</div>
<p><a href="colorquant1_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_color_quant_cell.html">ColorQuantCell</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_octcube_quant_cell.html">OctcubeQuantCell</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_l___octcube_pop.html">L_OctcubePop</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a6efa1730c3d1efaa20a5805a872230a5">DEBUG_OCTINDEX</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a9dd1f90352c8c2589d457d9dadaec559">DEBUG_OCTCUBE_CMAP</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#aad9aea776530afab6c9c52a186334e62">DEBUG_POP</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a5f5205ae6a33e8f90ecf3d36e1cd45a2">DEBUG_FEW_COLORS</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a9c48558207fa62d7e1c6705dc9cfa2ae">PRINT_OCTCUBE_STATS</a>&#160;&#160;&#160;0</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_color_quant_cell.html">ColorQuantCell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a7c765f9884156e0bcd29147aafdb3c34">CQCELL</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_octcube_quant_cell.html">OctcubeQuantCell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a904a0b378d20f654995ffcfccbd2d565">OQCELL</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_l___octcube_pop.html">L_OctcubePop</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a537098a7b148293e399afb1a484c56c6">L_OCTCUBE_POP</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a1807a67d3402b8a16831e145d8ea239f">octreeFindColorCell</a> (<a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> octindex, <a class="el" href="struct_color_quant_cell.html">CQCELL</a> ***cqcaa, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pindex, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *prval, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pgval, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pbval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_color_quant_cell.html">CQCELL</a> ***&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a92e168c2ca102186948df124b37f042b">octreeGenerateAndPrune</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="writetext__reg_8c.html#a4ebbf30ad0e54b03f69dd59a5fa97b18">colors</a>, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> reservedcolors, <a class="el" href="struct_pix_colormap.html">PIXCMAP</a> **pcmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#afebfd1d44adf9aba64c3209438b739e2">pixOctreeQuantizePixels</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_color_quant_cell.html">CQCELL</a> ***cqcaa, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> ditherflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_color_quant_cell.html">CQCELL</a> ***&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a65789003c15bfca5b7d303b4baa90f69">cqcellTreeCreate</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a583fa921ff138917a985a1c89b8bf66c">cqcellTreeDestroy</a> (<a class="el" href="struct_color_quant_cell.html">CQCELL</a> ****pcqcaa)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a0584f1f773ce375f03f540f5f8e6b5b2">getRGBFromOctcube</a> (<a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> cubeindex, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *prval, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pgval, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pbval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a7d4ae88ca70fb1367d1ad81501c16b52">getOctcubeIndices</a> (<a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> rgbindex, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pbindex, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *psindex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#abbb75ad068c16da65d75be4bd360da9e">octcubeGetCount</a> (<a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *psize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#ae9b9555af2a26e1403c6646e30b18a0f">pixDitherOctindexWithCmap</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pix.html">PIX</a> *pixd, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *rtab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *gtab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *btab, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *carray, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> difcap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a4021a336fd52303b8635172089f46708">pixOctreeColorQuant</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="writetext__reg_8c.html#a4ebbf30ad0e54b03f69dd59a5fa97b18">colors</a>, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> ditherflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a563fe9f0c788718722dafe10d22b16e2">pixOctreeColorQuantGeneral</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="writetext__reg_8c.html#a4ebbf30ad0e54b03f69dd59a5fa97b18">colors</a>, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> ditherflag, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> validthresh, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> colorthresh)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a795cf764d048c422fae9c0881e827967">makeRGBToIndexTables</a> (<a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> **prtab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> **pgtab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> **pbtab, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> cqlevels)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#af3066cc002e0b6e4ffe09d881744845f">getOctcubeIndexFromRGB</a> (<a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> rval, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> gval, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> bval, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *rtab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *gtab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *btab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *pindex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a22770d10755077f8d19e064225bf087e">pixOctreeQuantByPopulation</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> ditherflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#afc47c3e44c770c6f2937215ed7868b66">pixOctreeQuantNumColors</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> maxcolors, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> subsample)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a8a2436cf441f989fc3eeb22a46d656f4">pixOctcubeQuantMixedWithGray</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> depth, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> graylevels, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> delta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#aa0e721960a82b596c44ed7cc2608be0f">pixFixedOctcubeQuant256</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> ditherflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a1d2112468014c21e0a9879bb839c18ea">pixFewColorsOctcubeQuant1</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a4cdee00af2505828f935cf677fd15ce3">pixFewColorsOctcubeQuant2</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="struct_numa.html">NUMA</a> *na, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> ncolors, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pnerrors)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a8526360e93b594bb5278f551bcac8316">pixFewColorsOctcubeQuantMixed</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> darkthresh, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> lightthresh, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> diffthresh, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> minfract, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> maxspan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a2bbae086386e80478f2c90be735ad70c">pixFixedOctcubeQuantGenRGB</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a630809518ac5eaa4b63e710e4e02027e">pixQuantFromCmap</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *cmap, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> mindepth, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> metric)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a6e64581d313cbc09a362e8deb9839c0f">pixOctcubeQuantFromCmap</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *cmap, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> mindepth, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> metric)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a219f6fb87860960c149bd5fccee79da6">pixOctcubeQuantFromCmapLUT</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *cmap, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> mindepth, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *cmaptab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *rtab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *gtab, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *btab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_numa.html">NUMA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a34dc09d7a98fbee0cdb7ea7ce70ef3ed">pixOctcubeHistogram</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pncolors)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a49d0d706b36b0ee43c26254f51a034e8">pixcmapToOctcubeLUT</a> (<a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *cmap, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> metric)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#abab8a3de2731a11a794ea71be7d314f6">pixRemoveUnusedColors</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a4e4dfe00e261e215bfa58d8d17b917fe">pixNumberOccupiedOctcubes</a> (<a class="el" href="struct_pix.html">PIX</a> *pix, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> level, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> mincount, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> minfract, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pncolors)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a77df4766dd271cf68bdeee3a662f37cc">CQ_NLEVELS</a> = 5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a4a5cd7f3a842a6f9f0326f58093de698">CQ_RESERVED_COLORS</a> = 64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#aa9a70c49ba6a8c67c46478b39eaf6597">EXTRA_RESERVED_COLORS</a> = 25</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a12f4021215bed28ff3bdb80222cf350b">TREE_GEN_WIDTH</a> = 350</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a4e144e9ccf9bc547e929ab58baab30b4">MIN_DITHER_SIZE</a> = 250</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a04e295289ab4044bb32e0614d8af6cd6">FIXED_DIF_CAP</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="colorquant1_8c.html#a458ff947d8961e4c94867fbe38bfb5e2">POP_DIF_CAP</a> = 40</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Octcube color quantization. </p>

<p>Definition in file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a6efa1730c3d1efaa20a5805a872230a5"></a><!-- doxytag: member="colorquant1.c::DEBUG_OCTINDEX" ref="a6efa1730c3d1efaa20a5805a872230a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_OCTINDEX&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00230">230</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9dd1f90352c8c2589d457d9dadaec559"></a><!-- doxytag: member="colorquant1.c::DEBUG_OCTCUBE_CMAP" ref="a9dd1f90352c8c2589d457d9dadaec559" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_OCTCUBE_CMAP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00231">231</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

</div>
</div>
<a class="anchor" id="aad9aea776530afab6c9c52a186334e62"></a><!-- doxytag: member="colorquant1.c::DEBUG_POP" ref="aad9aea776530afab6c9c52a186334e62" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_POP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00232">232</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5f5205ae6a33e8f90ecf3d36e1cd45a2"></a><!-- doxytag: member="colorquant1.c::DEBUG_FEW_COLORS" ref="a5f5205ae6a33e8f90ecf3d36e1cd45a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_FEW_COLORS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00233">233</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9c48558207fa62d7e1c6705dc9cfa2ae"></a><!-- doxytag: member="colorquant1.c::PRINT_OCTCUBE_STATS" ref="a9c48558207fa62d7e1c6705dc9cfa2ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRINT_OCTCUBE_STATS&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00234">234</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a7c765f9884156e0bcd29147aafdb3c34"></a><!-- doxytag: member="colorquant1.c::CQCELL" ref="a7c765f9884156e0bcd29147aafdb3c34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_color_quant_cell.html">ColorQuantCell</a> <a class="el" href="struct_color_quant_cell.html">CQCELL</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00150">150</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

</div>
</div>
<a class="anchor" id="a904a0b378d20f654995ffcfccbd2d565"></a><!-- doxytag: member="colorquant1.c::OQCELL" ref="a904a0b378d20f654995ffcfccbd2d565" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_octcube_quant_cell.html">OctcubeQuantCell</a> <a class="el" href="struct_octcube_quant_cell.html">OQCELL</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00177">177</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

</div>
</div>
<a class="anchor" id="a537098a7b148293e399afb1a484c56c6"></a><!-- doxytag: member="colorquant1.c::L_OCTCUBE_POP" ref="a537098a7b148293e399afb1a484c56c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_l___octcube_pop.html">L_OctcubePop</a> <a class="el" href="struct_l___octcube_pop.html">L_OCTCUBE_POP</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00190">190</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1807a67d3402b8a16831e145d8ea239f"></a><!-- doxytag: member="colorquant1.c::octreeFindColorCell" ref="a1807a67d3402b8a16831e145d8ea239f" args="(l_int32 octindex, CQCELL ***cqcaa, l_int32 *pindex, l_int32 *prval, l_int32 *pgval, l_int32 *pbval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> octreeFindColorCell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>octindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_color_quant_cell.html">CQCELL</a> ***&#160;</td>
          <td class="paramname"><em>cqcaa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>prval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pgval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pbval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a1807a67d3402b8a16831e145d8ea239f">octreeFindColorCell()</a></p>
<p>Input: octindex cqcaa &amp;index (&lt;return&gt; index of CTE; returned to set pixel value) &amp;rval (&lt;return&gt; of CTE) &amp;gval (&lt;return&gt; of CTE) &amp;bval (&lt;return&gt; of CTE) Return: 0 if OK; 1 on error</p>
<p>Notes: (1) As this is in inner loop, we don't check input pointers! (2) This traverses from the root (well, actually from level 2, because the level 2 cubes are the largest CTE cubes), and finds the index number of the cell and the color values, which can be used either directly or in a (Floyd-Steinberg) error-diffusion dithering algorithm. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01144">1144</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00144">ColorQuantCell::bc</a>, <a class="el" href="colorquant1_8c_source.html#l00148">ColorQuantCell::bleaf</a>, <a class="el" href="colorquant1_8c_source.html#l00153">CQ_NLEVELS</a>, <a class="el" href="colorquant1_8c_source.html#l00144">ColorQuantCell::gc</a>, <a class="el" href="colorquant1_8c_source.html#l01537">getOctcubeIndices()</a>, <a class="el" href="colorquant1_8c_source.html#l01463">getRGBFromOctcube()</a>, <a class="el" href="colorquant1_8c_source.html#l00146">ColorQuantCell::index</a>, and <a class="el" href="colorquant1_8c_source.html#l00144">ColorQuantCell::rc</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l00932">pixOctreeQuantizePixels()</a>.</p>

</div>
</div>
<a class="anchor" id="a92e168c2ca102186948df124b37f042b"></a><!-- doxytag: member="colorquant1.c::octreeGenerateAndPrune" ref="a92e168c2ca102186948df124b37f042b" args="(PIX *pixs, l_int32 colors, l_int32 reservedcolors, PIXCMAP **pcmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_color_quant_cell.html">CQCELL</a> *** octreeGenerateAndPrune </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>reservedcolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix_colormap.html">PIXCMAP</a> **&#160;</td>
          <td class="paramname"><em>pcmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a92e168c2ca102186948df124b37f042b">octreeGenerateAndPrune()</a></p>
<p>Input: pixs number of colors to use (between 128 and 256) number of reserved colors &amp;cmap (made and returned) Return: octree, colormap and number of colors used, or null on error</p>
<p>Notes: (1) The number of colors in the cmap may differ from the number of colors requested, but it will not be larger than 256 </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00678">678</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00144">ColorQuantCell::bc</a>, <a class="el" href="colorquant1_8c_source.html#l00148">ColorQuantCell::bleaf</a>, <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="colorquant1_8c_source.html#l00153">CQ_NLEVELS</a>, <a class="el" href="colorquant1_8c_source.html#l01217">cqcellTreeCreate()</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="colorquant1_8c_source.html#l00156">EXTRA_RESERVED_COLORS</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00144">ColorQuantCell::gc</a>, <a class="el" href="colorquant1_8c_source.html#l01463">getRGBFromOctcube()</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00146">ColorQuantCell::index</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="pix_8h_source.html#l00106">PixColormap::n</a>, <a class="el" href="colorquant1_8c_source.html#l00145">ColorQuantCell::n</a>, <a class="el" href="colorquant1_8c_source.html#l00147">ColorQuantCell::nleaves</a>, <a class="el" href="colorquant1_8c_source.html#l00184">L_OctcubePop::npix</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="numabasic_8c_source.html#l00403">numaAddNumber()</a>, <a class="el" href="numabasic_8c_source.html#l00177">numaCreate()</a>, <a class="el" href="numabasic_8c_source.html#l00292">numaDestroy()</a>, <a class="el" href="numabasic_8c_source.html#l00557">numaGetCount()</a>, <a class="el" href="numabasic_8c_source.html#l00647">numaGetIValue()</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="colormap_8c_source.html#l00632">pixcmapGetColor()</a>, <a class="el" href="colormap_8c_source.html#l00909">pixcmapGetNearestIndex()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00144">ColorQuantCell::rc</a>, and <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l00562">pixOctreeColorQuantGeneral()</a>.</p>

</div>
</div>
<a class="anchor" id="afebfd1d44adf9aba64c3209438b739e2"></a><!-- doxytag: member="colorquant1.c::pixOctreeQuantizePixels" ref="afebfd1d44adf9aba64c3209438b739e2" args="(PIX *pixs, CQCELL ***cqcaa, l_int32 ditherflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_pix.html">PIX</a> * pixOctreeQuantizePixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_color_quant_cell.html">CQCELL</a> ***&#160;</td>
          <td class="paramname"><em>cqcaa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>ditherflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#afebfd1d44adf9aba64c3209438b739e2">pixOctreeQuantizePixels()</a></p>
<p>Input: pixs (32 bpp) octree in array format ditherflag (1 for dithering, 0 for no dithering) Return: pixd or null on error</p>
<p>Notes: (1) This routine doesn't need to use the CTEs (colormap table entries) because the color indices are embedded in the octree. Thus, the calling program must make and attach the colormap to pixd after it is returned. (2) Dithering is performed in integers, effectively rounding to 1/8 sample increment. The data in the integer buffers is 64 times the sample values. The 'dif' is 8 times the sample values, and this spread, multiplied by 8, to the integer buffers. Because the dif is truncated to an integer, the dither is accurate to 1/8 of a sample increment, or 1/2048 of the color range. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00932">932</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="colorquant1_8c_source.html#l00153">CQ_NLEVELS</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00155">L_MAX</a>, <a class="el" href="environ_8h_source.html#l00151">L_MIN</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colorquant1_8c_source.html#l01144">octreeFindColorCell()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix2_8c_source.html#l02161">pixGetRGBLine()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, and <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l00562">pixOctreeColorQuantGeneral()</a>.</p>

</div>
</div>
<a class="anchor" id="a65789003c15bfca5b7d303b4baa90f69"></a><!-- doxytag: member="colorquant1.c::cqcellTreeCreate" ref="a65789003c15bfca5b7d303b4baa90f69" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_color_quant_cell.html">CQCELL</a> *** cqcellTreeCreate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a65789003c15bfca5b7d303b4baa90f69">cqcellTreeCreate()</a></p>
<p>Input: none Return: cqcell array tree </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01217">1217</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="colorquant1_8c_source.html#l00153">CQ_NLEVELS</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l00678">octreeGenerateAndPrune()</a>.</p>

</div>
</div>
<a class="anchor" id="a583fa921ff138917a985a1c89b8bf66c"></a><!-- doxytag: member="colorquant1.c::cqcellTreeDestroy" ref="a583fa921ff138917a985a1c89b8bf66c" args="(CQCELL ****pcqcaa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void cqcellTreeDestroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_color_quant_cell.html">CQCELL</a> ****&#160;</td>
          <td class="paramname"><em>pcqcaa</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a583fa921ff138917a985a1c89b8bf66c">cqcellTreeDestroy()</a></p>
<p>Input: &amp;cqcaa (&lt;to be="" nulled&gt;=""&gt; Return: void </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01250">1250</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00153">CQ_NLEVELS</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l00562">pixOctreeColorQuantGeneral()</a>.</p>

</div>
</div>
<a class="anchor" id="a0584f1f773ce375f03f540f5f8e6b5b2"></a><!-- doxytag: member="colorquant1.c::getRGBFromOctcube" ref="a0584f1f773ce375f03f540f5f8e6b5b2" args="(l_int32 cubeindex, l_int32 level, l_int32 *prval, l_int32 *pgval, l_int32 *pbval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void getRGBFromOctcube </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>cubeindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>prval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pgval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pbval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a0584f1f773ce375f03f540f5f8e6b5b2">getRGBFromOctcube()</a></p>
<p>Input: octcube index level (at which index is expressed) &amp;rval (&lt;return&gt; r val of this cube) &amp;gval (&lt;return&gt; g val of this cube) &amp;bval (&lt;return&gt; b val of this cube) Return: void</p>
<p>Notes: (1) We can consider all octcube indices to represent a specific point in color space: namely, the location of the 'upper-left' corner of the cube, where indices increase down and to the right. The upper left corner of the color space is then 00000.... (2) The 'rgbindex' is a 24-bit representation of the location, in octcube notation, at the center of the octcube. To get to the center of an octcube, you choose the 111 octcube at the next lower level. (3) For example, if the octcube index = 110101 (binary), which is a level 2 expression, then the rgbindex is the 24-bit representation of 110101111 (at level 3); namely, 000110101111000000000000. The number is padded with 3 leading 0s (because the representation uses only 21 bits) and 12 trailing 0s (the default for levels 4-7, which are contained within each of the level3 octcubes. Then the rgb values for the center of the octcube are: rval = 11100000, gval = 10100000, bval = 01100000 </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01463">1463</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l01144">octreeFindColorCell()</a>, <a class="el" href="colorquant1_8c_source.html#l00678">octreeGenerateAndPrune()</a>, <a class="el" href="colorquant1_8c_source.html#l03758">pixcmapToOctcubeLUT()</a>, <a class="el" href="colorquant1_8c_source.html#l03335">pixFixedOctcubeQuantGenRGB()</a>, <a class="el" href="colorquant1_8c_source.html#l01641">pixOctreeQuantByPopulation()</a>, and <a class="el" href="colorquant1_8c_source.html#l02199">pixOctreeQuantNumColors()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d4ae88ca70fb1367d1ad81501c16b52"></a><!-- doxytag: member="colorquant1.c::getOctcubeIndices" ref="a7d4ae88ca70fb1367d1ad81501c16b52" args="(l_int32 rgbindex, l_int32 level, l_int32 *pbindex, l_int32 *psindex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> getOctcubeIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>rgbindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pbindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>psindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a7d4ae88ca70fb1367d1ad81501c16b52">getOctcubeIndices()</a></p>
<p>Input: rgbindex octree level (0, 1, 2, 3, 4, 5) &amp;octcube base index (&lt;return&gt; index at the octree level) &amp;octcube sub index (&lt;return&gt; index at the next lower level) Return: 0 if OK, 1 on error</p>
<p>for CQ_NLEVELS = 6, the full RGB index is in the form: index = (0[13] 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3 r2 g2 b2) for CQ_NLEVELS = 5, the full RGB index is in the form: index = (0[16] 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3) for CQ_NLEVELS = 4, the full RGB index is in the form: index = (0[19] 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4)</p>
<p>The base index is the index of the octcube at the level given, whereas the sub index is the index at the next level down.</p>
<p>For level 0: base index = 0 sub index is the 3 bit number (r7 g7 b7) For level 1: base index = (r7 g7 b7) sub index = (r7 g7 b7 r6 g6 b6) For level 2: base index = (r7 g7 b7 r6 g6 b6) sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5) For level 3: base index = (r7 g7 b7 r6 g6 b6 r5 g5 b5) sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4) For level 4: base index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4) sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3) For level 5: base index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3) sub index = (r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3 r2 g2 b2) </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01537">1537</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00153">CQ_NLEVELS</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l01144">octreeFindColorCell()</a>.</p>

</div>
</div>
<a class="anchor" id="abbb75ad068c16da65d75be4bd360da9e"></a><!-- doxytag: member="colorquant1.c::octcubeGetCount" ref="abbb75ad068c16da65d75be4bd360da9e" args="(l_int32 level, l_int32 *psize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> octcubeGetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>psize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#abbb75ad068c16da65d75be4bd360da9e">octcubeGetCount()</a></p>
<p>Input: level (valid values are in [1,...6]; there are 2^level cubes along each side of the rgb cube) &amp;size (&lt;return&gt; 2^(3 * level) cubes in the entire rgb cube) Return: 0 if OK, 1 on error. Caller must check!</p>
<p>level: 1 2 3 4 5 6 size: 8 64 512 4098 32784 262272 </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01569">1569</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l03758">pixcmapToOctcubeLUT()</a>, <a class="el" href="colorquant1_8c_source.html#l02870">pixFewColorsOctcubeQuant1()</a>, <a class="el" href="colorquant1_8c_source.html#l03985">pixNumberOccupiedOctcubes()</a>, <a class="el" href="colorquant1_8c_source.html#l03640">pixOctcubeHistogram()</a>, and <a class="el" href="colorquant1_8c_source.html#l01641">pixOctreeQuantByPopulation()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9b9555af2a26e1403c6646e30b18a0f"></a><!-- doxytag: member="colorquant1.c::pixDitherOctindexWithCmap" ref="ae9b9555af2a26e1403c6646e30b18a0f" args="(PIX *pixs, PIX *pixd, l_uint32 *rtab, l_uint32 *gtab, l_uint32 *btab, l_int32 *carray, l_int32 difcap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> pixDitherOctindexWithCmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>rtab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>gtab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>btab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>indexmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>difcap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#ae9b9555af2a26e1403c6646e30b18a0f">pixDitherOctindexWithCmap()</a></p>
<p>Input: pixs (32 bpp rgb) pixd (8 bpp cmapped) rtab, gtab, btab (tables from rval to octindex) indexmap (array mapping octindex to cmap index) difcap (max allowed dither transfer; use 0 for infinite cap) Return: 0 if OK, 1 on error</p>
<p>Notes: (1) This performs dithering to generate the colormap indices in pixd. The colormap has been calculated, along with four input LUTs that together give the inverse colormapping from RGB to colormap index. (2) For <a class="el" href="colorquant1_8c.html#a22770d10755077f8d19e064225bf087e">pixOctreeQuantByPopulation()</a>,  maps from the standard octindex to colormap index (after subtracting 1). The basic pixel-level function, without dithering, is: extractRGBValues(lines[j], &amp;rval, &amp;gval, &amp;bval); octindex = rtab[rval] | gtab[gval] | btab[bval]; SET_DATA_BYTE(lined, j, indexmap[octindex] - 1); (3) This can be used in any situation where the general prescription for finding the colormap index from the rgb value is precisely this: cmapindex = indexmap[rtab[rval] | gtab[gval] | btab[bval]] - 1 For example, in <a class="el" href="colorquant1_8c.html#aa0e721960a82b596c44ed7cc2608be0f">pixFixedOctcubeQuant256()</a>, we don't use standard octcube indexing, the rtab (etc) LUTs map directly to the colormap index, and  just compensates for the 1-off indexing assumed to be in that table. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01933">1933</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="environ_8h_source.html#l00155">L_MAX</a>, <a class="el" href="environ_8h_source.html#l00151">L_MIN</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00632">pixcmapGetColor()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00833">pixGetHeight()</a>, <a class="el" href="pix2_8c_source.html#l02161">pixGetRGBLine()</a>, <a class="el" href="pix1_8c_source.html#l00803">pixGetWidth()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, and <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l02743">pixFixedOctcubeQuant256()</a>, and <a class="el" href="colorquant1_8c_source.html#l01641">pixOctreeQuantByPopulation()</a>.</p>

</div>
</div>
<a class="anchor" id="a4021a336fd52303b8635172089f46708"></a><!-- doxytag: member="colorquant1.c::pixOctreeColorQuant" ref="a4021a336fd52303b8635172089f46708" args="(PIX *pixs, l_int32 colors, l_int32 ditherflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixOctreeColorQuant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>ditherflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a4021a336fd52303b8635172089f46708">pixOctreeColorQuant()</a></p>
<p>Input: pixs (32 bpp; 24-bit color) colors (in colormap; some number in range [128 ... 256]; the actual number of colors used will be smaller) ditherflag (1 to dither, 0 otherwise) Return: pixd (8 bpp with colormap), or null on error</p>
<p>I found one description in the literature of octree color quantization, using progressive truncation of the octree, by M. Gervautz and W. Purgathofer in Graphics Gems, pp. 287-293, ed. A. Glassner, Academic Press, 1990. Rather than setting up a fixed partitioning of the color space ab initio, as we do here, they allow the octree to be progressively truncated as new pixels are added. They need to set up some data structures that are traversed with the addition of each 24 bit pixel, in order to decide either (1) in which cluster (sub-branch of the octree) to put the pixel, or (2) whether to truncate the octree further to place the pixel in an existing cluster, or (3) which two existing clusters should be merged so that the pixel can be left to start a truncated leaf of the octree. Such dynamic truncation is considerably more complicated, and Gervautz et al. did not explain how they did it in anywhere near the detail required to check their implementation.</p>
<p>The simple method in <a class="el" href="colorquant1_8c.html#aa0e721960a82b596c44ed7cc2608be0f">pixFixedOctcubeQuant256()</a> is very fast, and with dithering the results are good, but you can do better if the color clusters are selected adaptively from the image. We want a method that makes much better use of color samples in regions of color space with high pixel density, while also fairly representing small numbers of color pixels in low density regions. Such adaptation requires two passes through the image: the first for generating the pruned tree of color cubes and the second for computing the index into the color table for each pixel.</p>
<p>A relatively simple adaptive method is <a class="el" href="colorquant1_8c.html#a22770d10755077f8d19e064225bf087e">pixOctreeQuantByPopulation()</a>. That function first determines if the image has very few colors, and, if so, quantizes to those colors. If there are more than 256 colors, it generates a histogram of octcube leaf occupancy at level 4, chooses the 192 most populated such leaves as the first 192 colors, and sets the remaining 64 colors to the residual average pixel values in each of the 64 level 2 octcubes. This is a bit faster than <a class="el" href="colorquant1_8c.html#a4021a336fd52303b8635172089f46708">pixOctreeColorQuant()</a>, and does very well without dithering, but for most images with dithering it is clearly inferior.</p>
<p>We now describe <a class="el" href="colorquant1_8c.html#a4021a336fd52303b8635172089f46708">pixOctreeColorQuant()</a>. The first pass is done on a subsampled image, because we do not need to use all the pixels in the image to generate the tree. Subsampling down to 0.25 (1/16 of the pixels) makes the program run about 1.3 times faster.</p>
<p>Instead of dividing the color space into 256 equal-sized regions, we initially divide it into 2^12 or 2^15 or 2^18 equal-sized octcubes. Suppose we choose to use 2^18 octcubes. This gives us 6 octree levels. We then prune back, starting from level 6. For every cube at level 6, there are 8 cubes at level 5. Call the operation of putting a cube aside as a color table entry (CTE) a "saving." We use a (in general) level-dependent threshold, and save those level 6 cubes that are above threshold. The rest are combined into the containing level 5 cube. If between 1 and 7 level 6 cubes within a level 5 cube have been saved by thresholding, then the remaining level 6 cubes in that level 5 cube are automatically saved as well, without applying a threshold. This greatly simplifies both the description of the CTEs and the later classification of each pixel as belonging to a CTE. This procedure is iterated through every cube, starting at level 5, and then 4, 3, and 2, successively. The result is that each CTE contains the entirety of a set of from 1 to 7 cubes from a given level that all belong to a single cube at the level above. We classify the CTEs in terms of the condition in which they are made as either being "threshold" or "residual." They are "threshold" CTEs if no subcubes are CTEs (that is, they contain every pixel within the cube) and the number of pixels exceeds the threshold for making a CTE. They are "residual" CTEs if at least one but not more than 7 of the subcubes have already been determined to be CTEs; this happens automatically -- no threshold is applied. If all 8 subcubes are determined to be CTEs, the cube is marked as having all pixels accounted for ('bleaf' = 1) but is not saved as a CTE.</p>
<p>We stop the pruning at level 2, at which there are 64 sub-cubes. Any pixels not already claimed in a CTE are put in these cubes.</p>
<p>As the cubes are saved as color samples in the color table, the number of remaining pixels P and the number of remaining colors in the color table N are recomputed, along with the average number of pixels P/N (ppc) to go in each of the remaining colors. This running average number is used to set the threshold at the current level.</p>
<p>Because we are going to very small cubes at levels 6 or 5, and will dither the colors for errors, it is not necessary to compute the color center of each cluster; we can simply use the center of the cube. This gives us a minimax error condition: the maximum error is half the width of the level 2 cubes -- 32 color values out of 256 -- for each color sample. In practice, most of the pixels will be very much closer to the center of their cells. And with dithering, the average pixel color in a small region will be closer still. Thus with the octree quantizer, we are able to capture regions of high color pdf (probability density function) in small but accurate CTEs, and to have only a small number of pixels that end up a significant distance (with a guaranteed maximum) from their true color.</p>
<p>How should the threshold factor vary? Threshold factors are required for levels 2, 3, 4 and 5 in the pruning stage. The threshold for level 5 is actually applied to cubes at level 6, etc. From various experiments, it appears that the results do not vary appreciably for threshold values near 1.0. If you want more colors in smaller cubes, the threshold factors can be set lower than 1.0 for cubes at levels 4 and 5. However, if the factor is set much lower than 1.0 for levels 2 and 3, we can easily run out of colors. We put aside 64 colors in the calculation of the threshold values, because we must have 64 color centers at level 2, that will have very few pixels in most of them. If we reduce the factor for level 5 to 0.4, this will generate many level 6 CTEs, and consequently many residual cells will be formed up from those leaves, resulting in the possibility of running out of colors. Remember, the residual CTEs are mandatory, and are formed without using the threshold, regardless of the number of pixels that are absorbed.</p>
<p>The implementation logically has four parts:</p>
<p>(1) accumulation into small, fixed cells (2) pruning back into selected CTE cubes (3) organizing the CTEs for fast search to find the CTE to which any image pixel belongs (4) doing a second scan to code the image pixels by CTE</p>
<p>Step (1) is straightforward; we use 2^15 cells.</p>
<p>We've already discussed how the pruning step (2) will be performed.</p>
<p>Steps (3) and (4) are related, in that the organization used by step (3) determines how the search actually takes place for each pixel in step (4).</p>
<p>There are many ways to do step (3). Let's explore a few.</p>
<p>(a) The simplest is to order the cubes from highest occupancy to lowest, and traverse the list looking for the deepest match. To make this more efficient, so that we know when to stop looking, any cube that has separate CTE subcubes would be marked as such, so that we know when we hit a true leaf.</p>
<p>(b) Alternatively, we can order the cubes by highest occupancy separately each level, and work upward, starting at level 5, so that when we find a match we know that it will be correct.</p>
<p>(c) Another approach would be to order the cubes by "address" and use a hash table to find the cube corresponding to a pixel color. I don't know how to do this with a variable length address, as each CTE will have 3*n bits, where n is the level.</p>
<p>(d) Another approach entirely is to put the CTE cubes into a tree, in such a way that starting from the root, and using 3 bits of address at a time, the correct branch of each octree can be taken until a leaf is found. Because a given cube can be both a leaf and also have branches going to sub-cubes, the search stops only when no marked subcubes have addresses that match the given pixel.</p>
<p>In the tree method, we can start with a dense infrastructure, and place the leaves corresponding to the N colors in the tree, or we can grow from the root only those branches that end directly on leaves.</p>
<p>What we do here is to take approach (d), and implement the tree "virtually", as a set of arrays, one array for each level of the tree. Initially we start at level 5, an array with 2^15 cubes, each with 8 subcubes. We then build nodes at levels closer to the root; at level 4 there are 2^12 nodes each with 8 subcubes; etc. Using these arrays has several advantages:</p>
<ul>
<li>We don't need to keep track of links between cubes and subcubes, because we can use the canonical addressing on the cell arrays directly to determine which nodes are parent cubes and which are sub-cubes.</li>
</ul>
<ul>
<li>We can prune directly on this tree</li>
</ul>
<ul>
<li>We can navigate the pruned tree quickly to classify each pixel in the image.</li>
</ul>
<p>Canonical addressing guarantees that the i-th node at level k has 8 subnodes given by the 8*i ... 8*i+7 nodes at level k+1.</p>
<p>The pruning step works as follows. We go from the lowest level up. At each level, the threshold is found from the product of a factor near 1.0 and the ratio of unmarked pixels to remaining colors (minus the 64). We march through the space, sequentially considering a cube and its 8 subcubes. We first check those subcubes that are not already marked as CTE to see if any are above threshold, and if so, generate a CTE and mark them as such. We then determine if any of the subcubes have been marked. If so, and there are subcubes that are not marked, we generate a CTE for the cube from the remaining unmarked subcubes; this is mandatory and does not depend on how many pixels are in the set of subcubes. If none of the subcubes are marked, we aggregate their pixels into the cube containing them, but do not mark it as a CTE; that will be determined when iterating through the next level up.</p>
<p>When all the pixels in a cube are accounted for in one or more colors, we set the boolean 'bleaf' to true. This is the flag used to mark the cubes in the pruning step. If a cube is marked, and all 8 subcubes are marked, then it is not itself given a CTE because all pixels have already been accounted for.</p>
<p>Note that the pruning of the tree and labelling of the CTEs (step 2) accomplishes step 3 implicitly, because the marked and pruned tree is ready for use in labelling each pixel in step 4. We now, for every pixel in the image, traverse the tree from the root, looking for the lowest cube that is a leaf. At each level we have a cube and subcube. If we reach a subcube leaf that is marked 0, we know that the color is stored in the cube above, and we've found the CTE. Otherwise, the subcube leaf is marked 1. If we're at the last level, we've reached the final leaf and must use it. Otherwise, continue the process at the next level down.</p>
<p>For robustness, efficiency and high quality output, we do the following:</p>
<p>(1) Measure the color content of the image. If there is very little color, quantize in grayscale. (2) For efficiency, build the octree with a subsampled image if the image is larger than some threshold size. (3) Reserve an extra set of colors to prevent running out of colors when pruning the octree; specifically, during the assignment of those level 2 cells (out of the 64) that have unassigned pixels. The problem of running out is more likely to happen with small images, because the estimation we use for the number of pixels available is not accurate. (4) In the unlikely event that we run out of colors, the dithered image can be very poor. As this would only happen with very small images, and dithering is not particularly noticeable with such images, turn it off. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00498">498</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="colorquant1_8c_source.html#l00562">pixOctreeColorQuantGeneral()</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="enhance__reg_8c_source.html#l00033">main()</a>, <a class="el" href="pixconv_8c_source.html#l01053">pixConvertRGBToColormap()</a>, and <a class="el" href="colorquant__reg_8c_source.html#l00055">TestImage()</a>.</p>

</div>
</div>
<a class="anchor" id="a563fe9f0c788718722dafe10d22b16e2"></a><!-- doxytag: member="colorquant1.c::pixOctreeColorQuantGeneral" ref="a563fe9f0c788718722dafe10d22b16e2" args="(PIX *pixs, l_int32 colors, l_int32 ditherflag, l_float32 validthresh, l_float32 colorthresh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixOctreeColorQuantGeneral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>ditherflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>validthresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>colorthresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a563fe9f0c788718722dafe10d22b16e2">pixOctreeColorQuantGeneral()</a></p>
<p>Input: pixs (32 bpp; 24-bit color) colors (in colormap; some number in range [128 ... 240]; the actual number of colors used will be smaller) ditherflag (1 to dither, 0 otherwise) validthresh (minimum fraction of pixels neither near white nor black, required for color quantization; typically ~0.01, but smaller for images that have color but are nearly all white) colorthresh (minimum fraction of pixels with color that are not near white or black, that are required for color quantization; typ. ~0.01, but smaller for images that have color along with a significant fraction of gray) Return: pixd (8 bit with colormap), or null on error</p>
<p>Notes: (1) The parameters  and  are used to determine if color quantization should be used on an image, or whether, instead, it should be quantized in grayscale. If the image has very few non-white and non-black pixels, or if those pixels that are non-white and non-black are all very close to either white or black, it is usually better to treat the color as accidental and to quantize the image to gray only. These parameters are useful if you know something a priori about the image. Perhaps you know that there is only a very small fraction of color pixels, but they're important to preserve; then you want to use a smaller value for these parameters. To disable conversion to gray and force color quantization, use  = 0.0 and  = 0.0. (2) See <a class="el" href="colorquant1_8c.html#a4021a336fd52303b8635172089f46708">pixOctreeColorQuant()</a> for algorithmic and implementation details. This function has a more general interface. (3) See <a class="el" href="colorcontent_8c.html#a3251f313c1c4c0d9184fec052e06cceb">pixColorFraction()</a> for computing the fraction of pixels that are neither white nor black, and the fraction of those pixels that have little color. From the documentation there: If pixfract is very small, there are few pixels that are neither black nor white. If colorfract is very small, the pixels that are neither black nor white have very little color content. The product 'pixfract * colorfract' gives the fraction of pixels with significant color content. We test against the product  *  to find color in images that have either very few intermediate gray pixels or that have many such gray pixels. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00562">562</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="colorquant1_8c_source.html#l00154">CQ_RESERVED_COLORS</a>, <a class="el" href="colorquant1_8c_source.html#l01250">cqcellTreeDestroy()</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00263">L_INFO</a>, <a class="el" href="environ_8h_source.html#l00268">L_INFO_FLOAT2</a>, <a class="el" href="environ_8h_source.html#l00265">L_INFO_INT</a>, <a class="el" href="environ_8h_source.html#l00155">L_MAX</a>, <a class="el" href="environ_8h_source.html#l00151">L_MIN</a>, <a class="el" href="colorquant1_8c_source.html#l00158">MIN_DITHER_SIZE</a>, <a class="el" href="pix_8h_source.html#l00106">PixColormap::n</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colorquant1_8c_source.html#l00678">octreeGenerateAndPrune()</a>, <a class="el" href="pix1_8c_source.html#l00440">pixClone()</a>, <a class="el" href="colormap_8c_source.html#l00632">pixcmapGetColor()</a>, <a class="el" href="colormap_8c_source.html#l00860">pixcmapGetRankIntensity()</a>, <a class="el" href="colormap_8c_source.html#l00705">pixcmapResetColor()</a>, <a class="el" href="colorcontent_8c_source.html#l00561">pixColorFraction()</a>, <a class="el" href="pixconv_8c_source.html#l02297">pixConvertTo8()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="colorquant1_8c_source.html#l00932">pixOctreeQuantizePixels()</a>, <a class="el" href="scale_8c_source.html#l00769">pixScaleBySampling()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, and <a class="el" href="colorquant1_8c_source.html#l00157">TREE_GEN_WIDTH</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l00498">pixOctreeColorQuant()</a>.</p>

</div>
</div>
<a class="anchor" id="a795cf764d048c422fae9c0881e827967"></a><!-- doxytag: member="colorquant1.c::makeRGBToIndexTables" ref="a795cf764d048c422fae9c0881e827967" args="(l_uint32 **prtab, l_uint32 **pgtab, l_uint32 **pbtab, l_int32 cqlevels)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> makeRGBToIndexTables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> **&#160;</td>
          <td class="paramname"><em>prtab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> **&#160;</td>
          <td class="paramname"><em>pgtab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> **&#160;</td>
          <td class="paramname"><em>pbtab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>cqlevels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a795cf764d048c422fae9c0881e827967">makeRGBToIndexTables()</a></p>
<p>Input: &amp;rtab, &amp;gtab, &amp;btab (&lt;return&gt; tables) cqlevels (can be 1, 2, 3, 4, 5 or 6) Return: 0 if OK; 1 on error</p>
<p>Set up tables. e.g., for cqlevels = 5, we need an integer 0 &lt; i &lt; 2^15: rtab = (0 i7 0 0 i6 0 0 i5 0 0 i4 0 0 i3 0 0) gtab = (0 0 i7 0 0 i6 0 0 i5 0 0 i4 0 0 i3 0) btab = (0 0 0 i7 0 0 i6 0 0 i5 0 0 i4 0 0 i3)</p>
<p>The tables are then used to map from rbg --&gt; index as follows: index = (0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4 r3 g3 b3)</p>
<p>e.g., for cqlevels = 4, we map to index = (0 0 0 0 r7 g7 b7 r6 g6 b6 r5 g5 b5 r4 g4 b4)</p>
<p>This may look a bit strange. The notation 'r7' means the MSBit of the r value (which has 8 bits, going down from r7 to r0). Keep in mind that r7 is actually the r component bit for level 1 of the octtree. Level 1 is composed of 8 octcubes, represented by the bits (r7 g7 b7), which divide the entire color space into 8 cubes. At level 2, each of these 8 octcubes is further divided into 8 cubes, each labeled by the second most significant bits (r6 g6 b6) of the rgb color. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01312">1312</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="cmapquant__reg_8c_source.html#l00031">main()</a>, <a class="el" href="colorquant1_8c_source.html#l00678">octreeGenerateAndPrune()</a>, <a class="el" href="colorseg_8c_source.html#l00373">pixAssignToNearestColor()</a>, <a class="el" href="colorquant1_8c_source.html#l02870">pixFewColorsOctcubeQuant1()</a>, <a class="el" href="colorquant1_8c_source.html#l03037">pixFewColorsOctcubeQuant2()</a>, <a class="el" href="colorquant1_8c_source.html#l03335">pixFixedOctcubeQuantGenRGB()</a>, <a class="el" href="colorquant1_8c_source.html#l03985">pixNumberOccupiedOctcubes()</a>, <a class="el" href="colorquant1_8c_source.html#l03640">pixOctcubeHistogram()</a>, <a class="el" href="colorquant1_8c_source.html#l03493">pixOctcubeQuantFromCmap()</a>, <a class="el" href="colorquant1_8c_source.html#l02524">pixOctcubeQuantMixedWithGray()</a>, <a class="el" href="colorquant1_8c_source.html#l01641">pixOctreeQuantByPopulation()</a>, <a class="el" href="colorquant1_8c_source.html#l00932">pixOctreeQuantizePixels()</a>, and <a class="el" href="colorquant1_8c_source.html#l02199">pixOctreeQuantNumColors()</a>.</p>

</div>
</div>
<a class="anchor" id="af3066cc002e0b6e4ffe09d881744845f"></a><!-- doxytag: member="colorquant1.c::getOctcubeIndexFromRGB" ref="af3066cc002e0b6e4ffe09d881744845f" args="(l_int32 rval, l_int32 gval, l_int32 bval, l_uint32 *rtab, l_uint32 *gtab, l_uint32 *btab, l_uint32 *pindex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getOctcubeIndexFromRGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>rval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>gval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>bval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>rtab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>gtab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>btab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>pindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#af3066cc002e0b6e4ffe09d881744845f">getOctcubeIndexFromRGB()</a></p>
<p>Input: rval, gval, bval rtab, gtab, btab (generated with <a class="el" href="colorquant1_8c.html#a795cf764d048c422fae9c0881e827967">makeRGBToIndexTables()</a>) &amp;index (&lt;return&gt;) Return: void</p>
<p>Note: no error checking! </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01419">1419</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, and <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>.</p>

<p>Referenced by <a class="el" href="colorseg_8c_source.html#l00373">pixAssignToNearestColor()</a>, <a class="el" href="colorquant1_8c_source.html#l03558">pixOctcubeQuantFromCmapLUT()</a>, and <a class="el" href="colorquant1_8c_source.html#l02199">pixOctreeQuantNumColors()</a>.</p>

</div>
</div>
<a class="anchor" id="a22770d10755077f8d19e064225bf087e"></a><!-- doxytag: member="colorquant1.c::pixOctreeQuantByPopulation" ref="a22770d10755077f8d19e064225bf087e" args="(PIX *pixs, l_int32 level, l_int32 ditherflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixOctreeQuantByPopulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>ditherflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a22770d10755077f8d19e064225bf087e">pixOctreeQuantByPopulation()</a></p>
<p>Input: pixs (32 bpp rgb) level (significant bits for each of RGB; valid for {3,4}, Use 0 for default (level 4; recommended) ditherflag (1 to dither, 0 otherwise) Return: pixd (quantized to octcubes) or null on error</p>
<p>Notes: (1) This color quantization method works very well without dithering, using octcubes at two different levels: (a) the input , which is either 3 or 4 (b) level 2 (64 octcubes to cover the entire color space) (2) For best results, using  = 4 is recommended. Why do we provide an option for using level 3? Because there are 512 octcubes at level 3, and for many images not more than 256 are filled. As a result, on some images a very accurate quantized representation is possible using  = 3. (3) This first breaks up the color space into octcubes at the input , and computes, for each octcube, the average value of the pixels that are in it. (4) Then there are two possible situations: (a) If there are not more than 256 populated octcubes, it returns a cmapped pix with those values assigned. (b) Otherwise, it selects 192 octcubes containing the largest number of pixels and quantizes pixels within those octcubes to their average. Then, to handle the residual pixels that are not in those 192 octcubes, it generates a level 2 octree consisting of 64 octcubes, and within each octcube it quantizes the residual pixels to their average within each of those level 2 octcubes. (5) Unpopulated level 2 octcubes are represented in the colormap by their centers. This, of course, has no effect unless dithering is used for the output image. (6) The depth of pixd is the minumum required to suppport the number of colors found at ; namely, 2, 4 or 8. (7) This function works particularly well on images such as maps, where there are a relatively small number of well-populated colors, but due to antialiasing and compression artifacts there may be a large number of different colors. This will pull out and represent accurately the highly populated colors, while still making a reasonable approximation for the others. (8) The highest level of octcubes allowed is 4. Use of higher levels typically results in having a small fraction of pixels in the most populated 192 octcubes. As a result, most of the pixels are represented at level 2, which is not sufficiently accurate. (9) Dithering shows artifacts on some images. If you plan to dither, <a class="el" href="colorquant1_8c.html#a4021a336fd52303b8635172089f46708">pixOctreeColorQuant()</a> and <a class="el" href="colorquant1_8c.html#aa0e721960a82b596c44ed7cc2608be0f">pixFixedOctcubeQuant256()</a> usually give better results. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l01641">1641</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l01463">getRGBFromOctcube()</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00263">L_INFO</a>, <a class="el" href="pix_8h_source.html#l00610">L_SORT_DECREASING</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="heap_8c_source.html#l00168">lheapAdd()</a>, <a class="el" href="heap_8c_source.html#l00088">lheapCreate()</a>, <a class="el" href="heap_8c_source.html#l00127">lheapDestroy()</a>, <a class="el" href="heap_8c_source.html#l00224">lheapRemove()</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="colorquant1_8c_source.html#l00158">MIN_DITHER_SIZE</a>, <a class="el" href="colorquant1_8c_source.html#l00184">L_OctcubePop::npix</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colorquant1_8c_source.html#l01569">octcubeGetCount()</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="colorquant1_8c_source.html#l01933">pixDitherOctindexWithCmap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="colorquant1_8c_source.html#l00199">POP_DIF_CAP</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00083">SET_DATA_DIBIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00100">SET_DATA_QBIT</a>, <a class="el" href="warper__reg_8c_source.html#l00027">size</a>, and <a class="el" href="environ_8h_source.html#l00175">TRUE</a>.</p>

<p>Referenced by <a class="el" href="colorquant__reg_8c_source.html#l00055">TestImage()</a>.</p>

</div>
</div>
<a class="anchor" id="afc47c3e44c770c6f2937215ed7868b66"></a><!-- doxytag: member="colorquant1.c::pixOctreeQuantNumColors" ref="afc47c3e44c770c6f2937215ed7868b66" args="(PIX *pixs, l_int32 maxcolors, l_int32 subsample)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixOctreeQuantNumColors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>maxcolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>subsample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#afc47c3e44c770c6f2937215ed7868b66">pixOctreeQuantNumColors()</a></p>
<p>Input: pixs (32 bpp rgb) maxcolors (8 to 256; the actual number of colors used may be less than this) subsample (factor for computing color distribution; use 0 for default) Return: pixd (4 or 8 bpp, colormapped), or null on error</p>
<p><a class="el" href="colorquant1_8c.html#a4021a336fd52303b8635172089f46708">pixOctreeColorQuant()</a> is very flexible in terms of the relative depth of different cubes of the octree. By contrast, this function, <a class="el" href="colorquant1_8c.html#afc47c3e44c770c6f2937215ed7868b66">pixOctreeQuantNumColors()</a> is also adaptive, but it supports octcube leaves at only two depths: a smaller depth that guarantees full coverage of the color space and octcubes at one level deeper for more accurate colors. Its main virutes are simplicity and speed, which are both derived from the natural indexing of the octcubes from the RGB values.</p>
<p>Before describing <a class="el" href="colorquant1_8c.html#afc47c3e44c770c6f2937215ed7868b66">pixOctreeQuantNumColors()</a>, consider an even simpler approach for 4 bpp with either 8 or 16 colors. With 8 colors, you simply go to level 1 octcubes and use the average color found in each cube. For 16 colors, you find which of the three colors has the largest variance at the second level, and use two indices for that color. The result is quite poor, because (1) some of the cubes are nearly empty and (2) you don't get much color differentiation for the extra 8 colors. Trust me, this method may be simple, but it isn't worth anything.</p>
<p>In <a class="el" href="colorquant1_8c.html#afc47c3e44c770c6f2937215ed7868b66">pixOctreeQuantNumColors()</a>, we generate colormapped images at either 4 bpp or 8 bpp. For 4 bpp, we have a minimum of 8 colors for the level 1 octcubes, plus up to 8 additional colors that are determined from the level 2 popularity. If the number of colors is between 8 and 16, the output is a 4 bpp image. If the number of colors is greater than 16, the output is a 8 bpp image.</p>
<p>We use a priority queue, implemented with a heap, to select the requisite number of most populated octcubes at the deepest level (level 2 for 64 or fewer colors; level 3 for more than 64 colors). These are combined with one color for each octcube one level above, which is used to span the color space of octcubes that were not included at the deeper level.</p>
<p>If the deepest level is 2, we combine the popular level 2 octcubes (out of a total of 64) with the 8 level 1 octcubes. If the deepest level is 3, we combine the popular level 3 octcubes (out of a total 512) with the 64 level 2 octcubes that span the color space. In the latter case, we require a minimum of 64 colors for the level 2 octcubes, plus up to 192 additional colors determined from level 3 popularity.</p>
<p>The parameter 'maxlevel' is the deepest octcube level that is used. The implementation also uses two LUTs, which are employed in two successive traversals of the dest image. The first maps from the src octindex at 'maxlevel' to the color table index, which is the value that is stored in the 4 or 8 bpp dest pixel. The second LUT maps from that colormap value in the dest to a new colormap value for a minimum sized colormap, stored back in the dest. It is used to remove any color map entries that correspond to color space regions that have no pixels in the source image. These regions can be either from the higher level (e.g., level 1 for 4 bpp), or from octcubes at 'maxlevel' that are unoccupied. This remapping results in the minimum number of colors used according to the constraints induced by the input 'maxcolors'. We also compute the average R, G and B color values in each region of the color space represented by a colormap entry, and store them in the colormap.</p>
<p>The maximum number of colors is input, which determines the following properties of the dest image and octcube regions used:</p>
<p>Number of colors dest image depth maxlevel ---------------- ---------------- -------- 8 to 16 4 bpp 2 17 to 64 8 bpp 2 65 to 256 8 bpp 3</p>
<p>It may turn out that the number of extra colors, beyond the minimum (8 and 64 for maxlevel 2 and 3, respectively), is larger than the actual number of occupied cubes at these levels In that case, all the pixels are contained in this subset of cubes at maxlevel, and no colormap colors are needed to represent the remainder pixels one level above. Thus, for example, in use one often finds that the pixels in an image occupy less than 192 octcubes at level 3, so they can be represented by a colormap for octcubes at level 3 only. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l02199">2199</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00174">OctcubeQuantCell::bcum</a>, <a class="el" href="colorquant1_8c_source.html#l00175">OctcubeQuantCell::bval</a>, <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00174">OctcubeQuantCell::gcum</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00097">GET_DATA_QBIT</a>, <a class="el" href="colorquant1_8c_source.html#l01419">getOctcubeIndexFromRGB()</a>, <a class="el" href="colorquant1_8c_source.html#l01463">getRGBFromOctcube()</a>, <a class="el" href="colorquant1_8c_source.html#l00175">OctcubeQuantCell::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00155">L_MAX</a>, <a class="el" href="environ_8h_source.html#l00151">L_MIN</a>, <a class="el" href="pix_8h_source.html#l00610">L_SORT_DECREASING</a>, <a class="el" href="heap_8c_source.html#l00168">lheapAdd()</a>, <a class="el" href="heap_8c_source.html#l00088">lheapCreate()</a>, <a class="el" href="heap_8c_source.html#l00127">lheapDestroy()</a>, <a class="el" href="heap_8c_source.html#l00224">lheapRemove()</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="colorquant1_8c_source.html#l00172">OctcubeQuantCell::n</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colorquant1_8c_source.html#l00173">OctcubeQuantCell::octindex</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="colormap_8c_source.html#l00517">pixcmapGetCount()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00174">OctcubeQuantCell::rcum</a>, <a class="el" href="colorquant1_8c_source.html#l00175">OctcubeQuantCell::rval</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00100">SET_DATA_QBIT</a>, and <a class="el" href="environ_8h_source.html#l00175">TRUE</a>.</p>

<p>Referenced by <a class="el" href="colorspacetest_8c_source.html#l00026">main()</a>, and <a class="el" href="colorquant__reg_8c_source.html#l00055">TestImage()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a2436cf441f989fc3eeb22a46d656f4"></a><!-- doxytag: member="colorquant1.c::pixOctcubeQuantMixedWithGray" ref="a8a2436cf441f989fc3eeb22a46d656f4" args="(PIX *pixs, l_int32 depth, l_int32 graylevels, l_int32 delta)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixOctcubeQuantMixedWithGray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>graylevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a8a2436cf441f989fc3eeb22a46d656f4">pixOctcubeQuantMixedWithGray()</a></p>
<p>Input: pixs (32 bpp rgb) depth (of output pix) graylevels (grayscale) delta (threshold for deciding if a pix is color or grayscale) Return: pixd (quantized to octcube and gray levels) or null on error</p>
<p>Notes: (1) Generates a colormapped image, where the colormap table values have two components: octcube values representing pixels with color content, and grayscale values for the rest. (2) The threshold (delta) is the maximum allowable difference of the max abs value of | r - g |, | r - b | and | g - b |. (3) The octcube values are the averages of all pixels that are found in the octcube, and that are far enough from gray to be considered color. This can roughly be visualized as all the points in the rgb color cube that are not within a "cylinder" of diameter approximately 'delta' along the main diagonal. (4) We want to guarantee full coverage of the rgb color space; thus, if the output depth is 4, the octlevel is 1 (2 x 2 x 2 = 8 cubes) and if the output depth is 8, the octlevel is 2 (4 x 4 x 4 = 64 cubes). (5) Consequently, we have the following constraint on the number of allowed gray levels: for 4 bpp, 8; for 8 bpp, 192. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l02524">2524</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="grayquant_8c_source.html#l01112">makeGrayQuantIndexTable()</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="colormap_8c_source.html#l00705">pixcmapResetColor()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00100">SET_DATA_QBIT</a>, and <a class="el" href="warper__reg_8c_source.html#l00027">size</a>.</p>

<p>Referenced by <a class="el" href="colorquant__reg_8c_source.html#l00055">TestImage()</a>.</p>

</div>
</div>
<a class="anchor" id="aa0e721960a82b596c44ed7cc2608be0f"></a><!-- doxytag: member="colorquant1.c::pixFixedOctcubeQuant256" ref="aa0e721960a82b596c44ed7cc2608be0f" args="(PIX *pixs, l_int32 ditherflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixFixedOctcubeQuant256 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>ditherflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#aa0e721960a82b596c44ed7cc2608be0f">pixFixedOctcubeQuant256()</a></p>
<p>Input: pixs (32 bpp; 24-bit color) ditherflag (1 for dithering; 0 for no dithering) Return: pixd (8 bit with colormap), or null on error</p>
<p>This simple 1-pass color quantization works by breaking the color space into 256 pieces, with 3 bits quantized for each of red and green, and 2 bits quantized for blue. We shortchange blue because the eye is least sensitive to blue. This division of the color space is into two levels of octrees, followed by a further division by 4 (not 8), where both blue octrees have been combined in the third level.</p>
<p>The color map is generated from the 256 color centers by taking the representative color to be the center of the cell volume. This gives a maximum error in the red and green values of 16 levels, and a maximum error in the blue sample of 32 levels.</p>
<p>Each pixel in the 24-bit color image is placed in its containing cell, given by the relevant MSbits of the red, green and blue samples. An error-diffusion dithering is performed on each color sample to give the appearance of good average local color. Dithering is required; without it, the contouring and visible color errors are very bad.</p>
<p>I originally implemented this algorithm in two passes, where the first pass was used to compute the weighted average of each sample in each pre-allocated region of color space. The idea was to use these centroids in the dithering algorithm of the second pass, to reduce the average error that was being dithered. However, with dithering, there is virtually no difference, so there is no reason to make the first pass. Consequently, this 1-pass version just assigns the pixels to the centers of the pre-allocated cells. We use dithering to spread the difference between the sample value and the location of the center of the cell. For speed and simplicity, we use integer dithering and propagate only to the right, down, and diagonally down-right, with ratios 3/8, 3/8 and 1/4, respectively. The results should be nearly as good, and a bit faster, with propagation only to the right and down.</p>
<p>The algorithm is very fast, because there is no search, only fast generation of the cell index for each pixel. We use a simple mapping from the three 8 bit rgb samples to the 8 bit cell index; namely, (r7 r6 r5 g7 g6 g5 b7 b6). This is not in an octcube format, but it doesn't matter. There are no storage requirements. We could keep a running average of the center of each sample in each cluster, rather than using the center of the cell, but this is just extra work, esp. with dithering.</p>
<p>This method gives surprisingly good results with dithering. However, without dithering, the loss of color accuracy is evident in regions that are very light or that have subtle blending of colors. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l02743">2743</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="colorquant1_8c_source.html#l00198">FIXED_DIF_CAP</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00263">L_INFO</a>, <a class="el" href="colorquant1_8c_source.html#l00158">MIN_DITHER_SIZE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="colorquant1_8c_source.html#l01933">pixDitherOctindexWithCmap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, and <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>.</p>

<p>Referenced by <a class="el" href="snapcolortest_8c_source.html#l00029">main()</a>, and <a class="el" href="colorquant__reg_8c_source.html#l00055">TestImage()</a>.</p>

</div>
</div>
<a class="anchor" id="a1d2112468014c21e0a9879bb839c18ea"></a><!-- doxytag: member="colorquant1.c::pixFewColorsOctcubeQuant1" ref="a1d2112468014c21e0a9879bb839c18ea" args="(PIX *pixs, l_int32 level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixFewColorsOctcubeQuant1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a1d2112468014c21e0a9879bb839c18ea">pixFewColorsOctcubeQuant1()</a></p>
<p>Input: pixs (32 bpp rgb) level (significant bits for each of RGB; valid in [1...6]) Return: pixd (quantized to octcube) or null on error</p>
<p>Notes: (1) Generates a colormapped image, where the colormap table values are the averages of all pixels that are found in the octcube. (2) This fails if there are more than 256 colors (i.e., more than 256 occupied octcubes). (3) Often level 3 (512 octcubes) will succeed because not more than half of them are occupied with 1 or more pixels. (4) The depth of the result, which is either 2, 4 or 8 bpp, is the minimum required to hold the number of colors that are found. (5) This can be useful for quantizing orthographically generated images such as color maps, where there may be more than 256 colors because of aliasing or jpeg artifacts on text or lines, but there are a relatively small number of solid colors. Then, use with level = 3 can often generate a compact and accurate representation of the original RGB image. For this purpose, it is better than <a class="el" href="colorquant1_8c.html#a4cdee00af2505828f935cf677fd15ce3">pixFewColorsOctcubeQuant2()</a>, because it uses the average value of pixels in the octcube rather than the first found pixel. It is also simpler to use, because it generates the histogram internally. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l02870">2870</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="environ_8h_source.html#l00259">L_WARNING_INT</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colorquant1_8c_source.html#l01569">octcubeGetCount()</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00083">SET_DATA_DIBIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00100">SET_DATA_QBIT</a>, and <a class="el" href="warper__reg_8c_source.html#l00027">size</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l03219">pixFewColorsOctcubeQuantMixed()</a>, <a class="el" href="pixconv_8c_source.html#l01127">pixQuantizeIfFewColors()</a>, and <a class="el" href="colorquant__reg_8c_source.html#l00055">TestImage()</a>.</p>

</div>
</div>
<a class="anchor" id="a4cdee00af2505828f935cf677fd15ce3"></a><!-- doxytag: member="colorquant1.c::pixFewColorsOctcubeQuant2" ref="a4cdee00af2505828f935cf677fd15ce3" args="(PIX *pixs, l_int32 level, NUMA *na, l_int32 ncolors, l_int32 *pnerrors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixFewColorsOctcubeQuant2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_numa.html">NUMA</a> *&#160;</td>
          <td class="paramname"><em>na</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>ncolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pnerrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a4cdee00af2505828f935cf677fd15ce3">pixFewColorsOctcubeQuant2()</a></p>
<p>Input: pixs (32 bpp rgb) level (of octcube indexing, for histogram: 3, 4, 5, 6) na (histogram of pixel occupation in octree leaves at given level) ncolors (number of occupied octree leaves at given level) &amp;nerrors (&lt;optional return&gt;=""&gt; num of pixels not exactly represented in the colormap) Return: pixd (2, 4 or 8 bpp with colormap), or null on error</p>
<p>Notes: (1) Generates a colormapped image, where the colormap table values are the averages of all pixels that are found in the octcube. (2) This fails if there are more than 256 colors (i.e., more than 256 occupied octcubes). (3) Often level 3 (512 octcubes) will succeed because not more than half of them are occupied with 1 or more pixels. (4) For an image with not more than 256 colors, it is unlikely that two pixels of different color will fall in the same octcube at level = 4. However it is possible, and this function optionally returns , the number of pixels where, because more than one color is in the same octcube, the pixel color is not exactly reproduced in the colormap. The colormap for an occupied leaf of the octree contains the color of the first pixel encountered in that octcube. (5) This differs from <a class="el" href="colorquant1_8c.html#a1d2112468014c21e0a9879bb839c18ea">pixFewColorsOctcubeQuant1()</a>, which also requires not more than 256 occupied leaves, but represents the color of each leaf by an average over the pixels in that leaf. This also requires precomputing the histogram of occupied octree leaves, which is generated using <a class="el" href="colorquant1_8c.html#a34dc09d7a98fbee0cdb7ea7ce70ef3ed">pixOctcubeHistogram()</a>. (6) This is used in <a class="el" href="leptprotos_8h.html#ae5c5c3c0b1377e147bd6171b7299e5aa">pixConvertRGBToColormap()</a> for images that are determined, by their histogram, to have relatively few colors. This typically happens with orthographically produced images (as oppopsed to natural images), where it is expected that most of the pixels within a leaf octcube have exactly the same color, and quantization to that color is lossless. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03037">3037</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="numabasic_8c_source.html#l00557">numaGetCount()</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, <a class="el" href="pix2_8c_source.html#l00546">setPixelLow()</a>, and <a class="el" href="environ_8h_source.html#l00167">UNDEF</a>.</p>

<p>Referenced by <a class="el" href="pixconv_8c_source.html#l01053">pixConvertRGBToColormap()</a>.</p>

</div>
</div>
<a class="anchor" id="a8526360e93b594bb5278f551bcac8316"></a><!-- doxytag: member="colorquant1.c::pixFewColorsOctcubeQuantMixed" ref="a8526360e93b594bb5278f551bcac8316" args="(PIX *pixs, l_int32 level, l_int32 darkthresh, l_int32 lightthresh, l_int32 diffthresh, l_float32 minfract, l_int32 maxspan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixFewColorsOctcubeQuantMixed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>darkthresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>lightthresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>diffthresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>minfract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>maxspan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a8526360e93b594bb5278f551bcac8316">pixFewColorsOctcubeQuantMixed()</a></p>
<p>Input: pixs (32 bpp rgb) level (significant octcube bits for each of RGB; valid in [1...6]; use 0 for default) darkthresh (threshold near black; if the lightest component is below this, the pixel is not considered to be gray or color; uses 0 for default) lightthresh (threshold near white; if the darkest component is above this, the pixel is not considered to be gray or color; use 0 for default) diffthresh (thresh for the max difference between component values; for differences below this, the pixel is considered to be gray; use 0 for default) considered gray; use 0 for default) minfract (min fraction of pixels for gray histo bin; use 0.0 for default) maxspan (max size of gray histo bin; use 0 for default) Return: pixd (8 bpp, quantized to octcube for pixels that are not gray; gray pixels are quantized separately over the full gray range), or null on error</p>
<p>Notes: (1) First runs <a class="el" href="colorquant1_8c.html#a1d2112468014c21e0a9879bb839c18ea">pixFewColorsOctcubeQuant1()</a>. If this succeeds, it separates the color from gray(ish) entries in the cmap, and re-quantizes the gray pixels. The result has some pixels in color and others in gray. (2) This fails if there are more than 256 colors (i.e., more than 256 occupied octcubes in the color quantization). (3) Level 3 (512 octcubes) will usually succeed because not more than half of them are occupied with 1 or more pixels. (4) This uses the criterion from <a class="el" href="colorcontent_8c.html#a3251f313c1c4c0d9184fec052e06cceb">pixColorFraction()</a> for deciding if a colormap entry is color; namely, if the color components are not too close to either black or white, and the maximum difference between component values equals or exceeds a threshold. (5) For quantizing the gray pixels, it uses a histogram-based method where input parameters determining the buckets are the minimum population fraction and the maximum allowed size. (6) Recommended input parameters are: : 3 or 4 (3 is default) : 20 : 244 : 20 : 0.05 : 15 These numbers are intended to be conservative (somewhat over- sensitive) in color detection, It's usually better to pay extra with octcube quantization of a grayscale image than to use grayscale quantization on an image that has some actual color. Input 0 on any of these to get the default. (7) This can be useful for quantizing orthographically generated images such as color maps, where there may be more than 256 colors because of aliasing or jpeg artifacts on text or lines, but there are a relatively small number of solid colors. It usually gives results that are better than <a class="el" href="colorquant1_8c.html#a8a2436cf441f989fc3eeb22a46d656f4">pixOctcubeQuantMixedWithGray()</a>, both in size and appearance. But it is a bit slower. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03219">3219</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00155">L_MAX</a>, <a class="el" href="environ_8h_source.html#l00151">L_MIN</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="colormap_8c_source.html#l00632">pixcmapGetColor()</a>, <a class="el" href="colormap_8c_source.html#l00517">pixcmapGetCount()</a>, <a class="el" href="pixconv_8c_source.html#l02297">pixConvertTo8()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="colorquant1_8c_source.html#l02870">pixFewColorsOctcubeQuant1()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="grayquant_8c_source.html#l01561">pixGrayQuantFromHisto()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, <a class="el" href="arrayaccess_8h_source.html#l00063">SET_DATA_BIT</a>, and <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>.</p>

</div>
</div>
<a class="anchor" id="a2bbae086386e80478f2c90be735ad70c"></a><!-- doxytag: member="colorquant1.c::pixFixedOctcubeQuantGenRGB" ref="a2bbae086386e80478f2c90be735ad70c" args="(PIX *pixs, l_int32 level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixFixedOctcubeQuantGenRGB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a2bbae086386e80478f2c90be735ad70c">pixFixedOctcubeQuantGenRGB()</a></p>
<p>Input: pixs (32 bpp rgb) level (significant bits for each of r,g,b) Return: pixd (rgb; quantized to octcube centers), or null on error</p>
<p>Notes: (1) Unlike the other color quantization functions, this one generates an rgb image. (2) The pixel values are quantized to the center of each octcube (at the specified level) containing the pixel. They are not quantized to the average of the pixels in that octcube. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03335">3335</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="pix2_8c_source.html#l02076">composeRGBPixel()</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l01463">getRGBFromOctcube()</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>.</p>

<p>Referenced by <a class="el" href="blend2__reg_8c_source.html#l00028">main()</a>, and <a class="el" href="colorquant__reg_8c_source.html#l00055">TestImage()</a>.</p>

</div>
</div>
<a class="anchor" id="a630809518ac5eaa4b63e710e4e02027e"></a><!-- doxytag: member="colorquant1.c::pixQuantFromCmap" ref="a630809518ac5eaa4b63e710e4e02027e" args="(PIX *pixs, PIXCMAP *cmap, l_int32 mindepth, l_int32 level, l_int32 metric)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixQuantFromCmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *&#160;</td>
          <td class="paramname"><em>cmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>mindepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a630809518ac5eaa4b63e710e4e02027e">pixQuantFromCmap()</a></p>
<p>Input: pixs (8 bpp grayscale without cmap, or 32 bpp rgb) cmap (to quantize to; insert copy into dest pix) mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp) level (of octcube used for finding nearest color in cmap) metric (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE) Return: pixd (2, 4 or 8 bpp, colormapped), or null on error</p>
<p>Notes: (1) This is a top-level wrapper for quantizing either grayscale or rgb images to a specified colormap. (2) The actual output depth is constrained by  and by the number of colors in . (3) For grayscale,  and  are ignored. (4) If the cmap has color and pixs is grayscale, the color is removed from the cmap before quantizing pixs. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03406">3406</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="grayquant_8c_source.html#l01780">pixGrayQuantFromCmap()</a>, <a class="el" href="colorquant1_8c_source.html#l03493">pixOctcubeQuantFromCmap()</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="writetext__reg_8c_source.html#l00049">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a6e64581d313cbc09a362e8deb9839c0f"></a><!-- doxytag: member="colorquant1.c::pixOctcubeQuantFromCmap" ref="a6e64581d313cbc09a362e8deb9839c0f" args="(PIX *pixs, PIXCMAP *cmap, l_int32 mindepth, l_int32 level, l_int32 metric)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixOctcubeQuantFromCmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *&#160;</td>
          <td class="paramname"><em>cmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>mindepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a6e64581d313cbc09a362e8deb9839c0f">pixOctcubeQuantFromCmap()</a></p>
<p>Input: pixs (32 bpp rgb) cmap (to quantize to; insert copy into dest pix) mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp) level (of octcube used for finding nearest color in cmap) metric (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE) Return: pixd (2, 4 or 8 bpp, colormapped), or null on error</p>
<p>Notes: (1) In typical use, we are doing an operation, such as interpolative scaling, on a colormapped pix, where it is necessary to remove the colormap before the operation. We then want to re-quantize the RGB result using the same colormap. (2) The level is used to divide the color space into octcubes. Each input pixel is, in effect, placed at the center of an octcube at the given level, and it is mapped into the exact color (given in the colormap) that is the closest to that location. We need to know that distance, for each color in the colormap. The higher the level of the octtree, the smaller the octcubes in the color space, and hence the more accurately we can determine the closest color in the colormap; however, the size of the LUT, which is the total number of octcubes, increases by a factor of 8 for each increase of 1 level. The time required to acquire a level 4 mapping table, which has about 4K entries, is less than 1 msec, so that is the recommended minimum size to be used. At that size, the octcubes have their centers 16 units apart in each (r,g,b) direction. If two colors are in the same octcube, the one closest to the center will always be chosen. The maximum error for any component occurs when the correct color is at a cube corner and there is an incorrect color just inside the cube next to the opposite corner, giving an error of 14 units (out of 256) for each component. Using a level 5 mapping table reduces the maximum error to 6 units. (3) Typically you should use the Euclidean metric, because the resulting voronoi cells (which are generated using the actual colormap values as seeds) are convex for Euclidean distance but not for Manhattan distance. In terms of the octcubes, convexity of the voronoi cells means that if the 8 corners of any cube (of which the octcubes are special cases) are all within a cell, then every point in the cube will lie within the cell. (4) The depth of the output pixd is equal to the maximum of (a)  and (b) the minimum (2, 4 or 8 bpp) necessary to hold the indices in the colormap. (5) We build a mapping table from octcube to colormap index so that this function can run in a time (otherwise) independent of the number of colors in the colormap. This avoids a brute-force search for the closest colormap color to each pixel in the image. (6) This is similar to the function <a class="el" href="colorseg_8c.html#add6a22eb71424598dd36dc3358d475b1">pixAssignToNearestColor()</a> used for color segmentation. (7) Except for very small images or when using level &gt; 4, it takes very little time to generate the tables, compared to the generation of the colormapped dest pix, so one would not typically use the low-level version. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03493">3493</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="pix_8h_source.html#l00753">L_EUCLIDEAN_DISTANCE</a>, <a class="el" href="pix_8h_source.html#l00752">L_MANHATTAN_DISTANCE</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colorquant1_8c_source.html#l03758">pixcmapToOctcubeLUT()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="colorquant1_8c_source.html#l03558">pixOctcubeQuantFromCmapLUT()</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="cmapquant__reg_8c_source.html#l00031">main()</a>, and <a class="el" href="colorquant1_8c_source.html#l03406">pixQuantFromCmap()</a>.</p>

</div>
</div>
<a class="anchor" id="a219f6fb87860960c149bd5fccee79da6"></a><!-- doxytag: member="colorquant1.c::pixOctcubeQuantFromCmapLUT" ref="a219f6fb87860960c149bd5fccee79da6" args="(PIX *pixs, PIXCMAP *cmap, l_int32 mindepth, l_int32 *cmaptab, l_uint32 *rtab, l_uint32 *gtab, l_uint32 *btab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixOctcubeQuantFromCmapLUT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *&#160;</td>
          <td class="paramname"><em>cmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>mindepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>cmaptab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>rtab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>gtab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>btab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a219f6fb87860960c149bd5fccee79da6">pixOctcubeQuantFromCmapLUT()</a></p>
<p>Input: pixs (32 bpp rgb) cmap (to quantize to; insert copy into dest pix) mindepth (minimum depth of pixd: can be 2, 4 or 8 bpp) cmaptab (table mapping from octindex to colormap index) rtab, gtab, btab (tables mapping from RGB to octindex) Return: pixd (2, 4 or 8 bpp, colormapped), or null on error</p>
<p>Notes: (1) See the notes in the higher-level function <a class="el" href="colorquant1_8c.html#a6e64581d313cbc09a362e8deb9839c0f">pixOctcubeQuantFromCmap()</a>. The octcube level for the generated octree is specified there, along with the distance metric for determining the closest color in the colormap to each octcube. (2) If the colormap, level and metric information have already been used to construct the set of mapping tables, this low-level function can be used directly (i.e., independently of <a class="el" href="colorquant1_8c.html#a6e64581d313cbc09a362e8deb9839c0f">pixOctcubeQuantFromCmap()</a>) to build a colormapped pix that uses the specified colormap. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03558">3558</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="colorquant1_8c_source.html#l01419">getOctcubeIndexFromRGB()</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00155">L_MAX</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00207">pixcmapCopy()</a>, <a class="el" href="colormap_8c_source.html#l00575">pixcmapGetMinDepth()</a>, <a class="el" href="pix1_8c_source.html#l01176">pixCopyInputFormat()</a>, <a class="el" href="pix1_8c_source.html#l01114">pixCopyResolution()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00083">SET_DATA_DIBIT</a>, and <a class="el" href="arrayaccess_8h_source.html#l00100">SET_DATA_QBIT</a>.</p>

<p>Referenced by <a class="el" href="cmapquant__reg_8c_source.html#l00031">main()</a>, and <a class="el" href="colorquant1_8c_source.html#l03493">pixOctcubeQuantFromCmap()</a>.</p>

</div>
</div>
<a class="anchor" id="a34dc09d7a98fbee0cdb7ea7ce70ef3ed"></a><!-- doxytag: member="colorquant1.c::pixOctcubeHistogram" ref="a34dc09d7a98fbee0cdb7ea7ce70ef3ed" args="(PIX *pixs, l_int32 level, l_int32 *pncolors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_numa.html">NUMA</a>* pixOctcubeHistogram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pncolors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a34dc09d7a98fbee0cdb7ea7ce70ef3ed">pixOctcubeHistogram()</a></p>
<p>Input: pixs (32 bpp rgb) level (significant bits for each of RGB; valid in [1...6]) &amp;ncolors (&lt;optional return&gt;=""&gt; number of occupied cubes) Return: numa (histogram of color pixels, or null on error)</p>
<p>Notes: (1) Input NULL for &amp;ncolors to prevent computation and return value. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03640">3640</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="pix_8h_source.html#l00602">L_NOCOPY</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="numabasic_8c_source.html#l00177">numaCreate()</a>, <a class="el" href="numabasic_8c_source.html#l00781">numaGetFArray()</a>, <a class="el" href="numabasic_8c_source.html#l00647">numaGetIValue()</a>, <a class="el" href="numabasic_8c_source.html#l00582">numaSetCount()</a>, <a class="el" href="colorquant1_8c_source.html#l01569">octcubeGetCount()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, and <a class="el" href="warper__reg_8c_source.html#l00027">size</a>.</p>

<p>Referenced by <a class="el" href="histotest_8c_source.html#l00035">main()</a>, and <a class="el" href="pixconv_8c_source.html#l01053">pixConvertRGBToColormap()</a>.</p>

</div>
</div>
<a class="anchor" id="a49d0d706b36b0ee43c26254f51a034e8"></a><!-- doxytag: member="colorquant1.c::pixcmapToOctcubeLUT" ref="a49d0d706b36b0ee43c26254f51a034e8" args="(PIXCMAP *cmap, l_int32 level, l_int32 metric)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>* pixcmapToOctcubeLUT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix_colormap.html">PIXCMAP</a> *&#160;</td>
          <td class="paramname"><em>cmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a49d0d706b36b0ee43c26254f51a034e8">pixcmapToOctcubeLUT()</a></p>
<p>Input: cmap level (significant bits for each of RGB; valid in [1...6]) metric (L_MANHATTAN_DISTANCE, L_EUCLIDEAN_DISTANCE) Return: tab[2**(3 * level)]</p>
<p>Notes: (1) This function is used to quickly find the colormap color that is closest to any rgb color. It is used to assign rgb colors to an existing colormap. It can be very expensive to search through the entire colormap for the closest color to each pixel. Instead, we first set up this table, which is populated by the colormap index nearest to each octcube color. Then we go through the image; for each pixel, do two table lookups: first to generate the octcube index from rgb and second to use this table to read out the colormap index. (2) Do a slight modification for white and black. For level = 4, each octcube size is 16. The center of the whitest octcube is at (248, 248, 248), which is closer to 242 than 255. Consequently, any gray color between 242 and 254 will be selected, even if white (255, 255, 255) exists. This is typically not optimal, because the original color was likely white. Therefore, if white exists in the colormap, use it for any rgb color that falls into the most white octcube. Do the similar thing for black. (3) Here are the actual function calls for quantizing to a specified colormap:</p>
<ul>
<li>first make the tables that map from rgb --&gt; octcube index <a class="el" href="colorquant1_8c.html#a795cf764d048c422fae9c0881e827967">makeRGBToIndexTables()</a></li>
<li>then for each pixel: * use the tables to get the octcube index <a class="el" href="colorquant1_8c.html#af3066cc002e0b6e4ffe09d881744845f">getOctcubeIndexFromRGB()</a> * use this table to get the nearest color in the colormap cmap_index = tab[index] (4) Distance can be either manhattan or euclidean. (5) In typical use, level = 4 gives reasonable results, and level = 5 is slightly better. When this function is used for color segmentation, there are typically a small number of colors and the number of levels can be small (e.g., level = 3). </li>
</ul>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03758">3758</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l01463">getRGBFromOctcube()</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00159">L_ABS</a>, <a class="el" href="pix_8h_source.html#l00753">L_EUCLIDEAN_DISTANCE</a>, <a class="el" href="pix_8h_source.html#l00752">L_MANHATTAN_DISTANCE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colorquant1_8c_source.html#l01569">octcubeGetCount()</a>, <a class="el" href="colormap_8c_source.html#l00632">pixcmapGetColor()</a>, <a class="el" href="colormap_8c_source.html#l00517">pixcmapGetCount()</a>, <a class="el" href="colormap_8c_source.html#l00909">pixcmapGetNearestIndex()</a>, <a class="el" href="colormap_8c_source.html#l01297">pixcmapToArrays()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, and <a class="el" href="warper__reg_8c_source.html#l00027">size</a>.</p>

<p>Referenced by <a class="el" href="cmapquant__reg_8c_source.html#l00031">main()</a>, <a class="el" href="colorseg_8c_source.html#l00373">pixAssignToNearestColor()</a>, and <a class="el" href="colorquant1_8c_source.html#l03493">pixOctcubeQuantFromCmap()</a>.</p>

</div>
</div>
<a class="anchor" id="abab8a3de2731a11a794ea71be7d314f6"></a><!-- doxytag: member="colorquant1.c::pixRemoveUnusedColors" ref="abab8a3de2731a11a794ea71be7d314f6" args="(PIX *pixs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> pixRemoveUnusedColors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#abab8a3de2731a11a794ea71be7d314f6">pixRemoveUnusedColors()</a></p>
<p>Input: pixs (colormapped) Return: 0 if OK, 1 on error</p>
<p>Notes: (1) This is an in-place operation. (2) If the image doesn't have a colormap, returns without error. (3) Unusued colors are removed from the colormap, and the image pixels are re-numbered. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03843">3843</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00179">FALSE</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00080">GET_DATA_DIBIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00097">GET_DATA_QBIT</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="colorquant1_8c_source.html#l00185">L_OctcubePop::index</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colormap_8c_source.html#l00271">pixcmapAddColor()</a>, <a class="el" href="colormap_8c_source.html#l00085">pixcmapCreate()</a>, <a class="el" href="colormap_8c_source.html#l00632">pixcmapGetColor()</a>, <a class="el" href="colormap_8c_source.html#l00517">pixcmapGetCount()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix1_8c_source.html#l01312">pixSetColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00083">SET_DATA_DIBIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00100">SET_DATA_QBIT</a>, and <a class="el" href="environ_8h_source.html#l00175">TRUE</a>.</p>

<p>Referenced by <a class="el" href="colorseg_8c_source.html#l00535">pixColorSegmentRemoveColors()</a>, and <a class="el" href="blend_8c_source.html#l01887">pixSnapColorCmap()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e4dfe00e261e215bfa58d8d17b917fe"></a><!-- doxytag: member="colorquant1.c::pixNumberOccupiedOctcubes" ref="a4e4dfe00e261e215bfa58d8d17b917fe" args="(PIX *pix, l_int32 level, l_int32 mincount, l_float32 minfract, l_int32 *pncolors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> pixNumberOccupiedOctcubes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>mincount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>minfract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pncolors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="colorquant1_8c.html#a4e4dfe00e261e215bfa58d8d17b917fe">pixNumberOccupiedOctcubes()</a></p>
<p>Input: pix (32 bpp) level (of octcube) mincount (minimum num pixels in an octcube to be counted; -1 to not use) minfract (minimum fract of pixels in an octcube to be counted; -1 to not use) &amp;ncolors (&lt;return&gt; number of occupied octcubes) Return: 0 if OK, 1 on error</p>
<p>Notes: (1) Exactly one of (, ) must be -1, so, e.g., if  == -1, then we use . (2) If all occupied octcubes are to count, set  == 1. Setting  == 0.0 is taken to mean the same thing. </p>

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l03985">3985</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>References <a class="el" href="colorquant1_8c_source.html#l00188">L_OctcubePop::bval</a>, <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="pix2_8c_source.html#l02108">extractRGBValues()</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="colorquant1_8c_source.html#l00187">L_OctcubePop::gval</a>, <a class="el" href="environ_8h_source.html#l00151">L_MIN</a>, <a class="el" href="colorquant1_8c_source.html#l01312">makeRGBToIndexTables()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="colorquant1_8c_source.html#l01569">octcubeGetCount()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="colorquant1_8c_source.html#l00186">L_OctcubePop::rval</a>, and <a class="el" href="warper__reg_8c_source.html#l00027">size</a>.</p>

<p>Referenced by <a class="el" href="colorcontent_8c_source.html#l00766">pixColorsForQuantization()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a77df4766dd271cf68bdeee3a662f37cc"></a><!-- doxytag: member="colorquant1.c::CQ_NLEVELS" ref="a77df4766dd271cf68bdeee3a662f37cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="colorquant1_8c.html#a77df4766dd271cf68bdeee3a662f37cc">CQ_NLEVELS</a> = 5<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00153">153</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l01217">cqcellTreeCreate()</a>, <a class="el" href="colorquant1_8c_source.html#l01250">cqcellTreeDestroy()</a>, <a class="el" href="colorquant1_8c_source.html#l01537">getOctcubeIndices()</a>, <a class="el" href="colorquant1_8c_source.html#l01144">octreeFindColorCell()</a>, <a class="el" href="colorquant1_8c_source.html#l00678">octreeGenerateAndPrune()</a>, and <a class="el" href="colorquant1_8c_source.html#l00932">pixOctreeQuantizePixels()</a>.</p>

</div>
</div>
<a class="anchor" id="a4a5cd7f3a842a6f9f0326f58093de698"></a><!-- doxytag: member="colorquant1.c::CQ_RESERVED_COLORS" ref="a4a5cd7f3a842a6f9f0326f58093de698" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="colorquant1_8c.html#a4a5cd7f3a842a6f9f0326f58093de698">CQ_RESERVED_COLORS</a> = 64<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00154">154</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l00562">pixOctreeColorQuantGeneral()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9a70c49ba6a8c67c46478b39eaf6597"></a><!-- doxytag: member="colorquant1.c::EXTRA_RESERVED_COLORS" ref="aa9a70c49ba6a8c67c46478b39eaf6597" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="colorquant1_8c.html#aa9a70c49ba6a8c67c46478b39eaf6597">EXTRA_RESERVED_COLORS</a> = 25<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00156">156</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l00678">octreeGenerateAndPrune()</a>.</p>

</div>
</div>
<a class="anchor" id="a12f4021215bed28ff3bdb80222cf350b"></a><!-- doxytag: member="colorquant1.c::TREE_GEN_WIDTH" ref="a12f4021215bed28ff3bdb80222cf350b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="colorquant1_8c.html#a12f4021215bed28ff3bdb80222cf350b">TREE_GEN_WIDTH</a> = 350<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00157">157</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l00562">pixOctreeColorQuantGeneral()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e144e9ccf9bc547e929ab58baab30b4"></a><!-- doxytag: member="colorquant1.c::MIN_DITHER_SIZE" ref="a4e144e9ccf9bc547e929ab58baab30b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="colorquant1_8c.html#a4e144e9ccf9bc547e929ab58baab30b4">MIN_DITHER_SIZE</a> = 250<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00158">158</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l02743">pixFixedOctcubeQuant256()</a>, <a class="el" href="colorquant1_8c_source.html#l00562">pixOctreeColorQuantGeneral()</a>, and <a class="el" href="colorquant1_8c_source.html#l01641">pixOctreeQuantByPopulation()</a>.</p>

</div>
</div>
<a class="anchor" id="a04e295289ab4044bb32e0614d8af6cd6"></a><!-- doxytag: member="colorquant1.c::FIXED_DIF_CAP" ref="a04e295289ab4044bb32e0614d8af6cd6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="colorquant1_8c.html#a04e295289ab4044bb32e0614d8af6cd6">FIXED_DIF_CAP</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00198">198</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l02743">pixFixedOctcubeQuant256()</a>.</p>

</div>
</div>
<a class="anchor" id="a458ff947d8961e4c94867fbe38bfb5e2"></a><!-- doxytag: member="colorquant1.c::POP_DIF_CAP" ref="a458ff947d8961e4c94867fbe38bfb5e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> <a class="el" href="colorquant1_8c.html#a458ff947d8961e4c94867fbe38bfb5e2">POP_DIF_CAP</a> = 40<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="colorquant1_8c_source.html#l00199">199</a> of file <a class="el" href="colorquant1_8c_source.html">colorquant1.c</a>.</p>

<p>Referenced by <a class="el" href="colorquant1_8c_source.html#l01641">pixOctreeQuantByPopulation()</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="colorquant1_8c.html">colorquant1.c</a>      </li>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
