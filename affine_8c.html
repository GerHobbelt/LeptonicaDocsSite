<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Leptonica: src/affine.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="moller52-tiny.jpg"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Leptonica&#160;<span id="projectnumber">1.68</span></div>
   <div id="projectbrief">C Image Processing Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('affine_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>affine.c File Reference</h1>  </div>
</div>
<div class="contents">

<p>3-pt affine transforms on images and coordinates, with sampling and interpolation; gauss-jordan solver  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;math.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="allheaders_8h_source.html">allheaders.h</a>&quot;</code><br/>
</div>
<p><a href="affine_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#ad72dbcf6d0153db1b8d8a58001feed83">DEBUG</a>&#160;&#160;&#160;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#aac9153aee4bdb92701df902e06a74eb3">SWAP</a>(a, b)&#160;&#160;&#160;{temp = (a); (a) = (b); (b) = temp;}</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a8e84c9c625b81eaa272a78ba32b2a7ea">pixAffineSampledPta</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pta.html">PTA</a> *ptad, <a class="el" href="struct_pta.html">PTA</a> *ptas, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> incolor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#ab761f82134e4973ba70bb7d5bdb62542">pixAffineSampled</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *vc, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> incolor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a2264192bf053eccba3233b9840590d6e">pixAffinePta</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pta.html">PTA</a> *ptad, <a class="el" href="struct_pta.html">PTA</a> *ptas, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> incolor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a6d86935bd696bd2431cd17136771c519">pixAffine</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *vc, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> incolor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#aed5a65a5f747035b9aad508afac6f67d">pixAffinePtaColor</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pta.html">PTA</a> *ptad, <a class="el" href="struct_pta.html">PTA</a> *ptas, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> colorval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a06d77d39bbd430ce000f88b7302d17b4">pixAffineColor</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *vc, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> colorval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a5f2ec4d911f8f0388cc40ecf48cd0645">pixAffinePtaGray</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pta.html">PTA</a> *ptad, <a class="el" href="struct_pta.html">PTA</a> *ptas, <a class="el" href="environ_8h.html#a7ed60554e7d6dd89aca643189b1e70ad">l_uint8</a> grayval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a58c3e8f9e6e6d33e074aecfbbc1d310a">pixAffineGray</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *vc, <a class="el" href="environ_8h.html#a7ed60554e7d6dd89aca643189b1e70ad">l_uint8</a> grayval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#afd63168e13d35247c9e21d6e59f09567">pixAffinePtaWithAlpha</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pta.html">PTA</a> *ptad, <a class="el" href="struct_pta.html">PTA</a> *ptas, <a class="el" href="struct_pix.html">PIX</a> *pixg, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> fract, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> border)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#ac11c1ec1133dc6625c6c589bf4d54663">pixAffinePtaGammaXform</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> gamma, <a class="el" href="struct_pta.html">PTA</a> *ptad, <a class="el" href="struct_pta.html">PTA</a> *ptas, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> fract, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> border)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a6dbd9d7ffdcb98cb9bdeb3d1ca67e4c4">getAffineXformCoeffs</a> (<a class="el" href="struct_pta.html">PTA</a> *ptas, <a class="el" href="struct_pta.html">PTA</a> *ptad, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> **pvc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a4bec7268ce4521fcc08cb33b5e5c1c4a">affineInvertXform</a> (<a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *vc, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> **pvci)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#adf6502edf7823f552db9236cba693dc3">affineXformSampledPt</a> (<a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *vc, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> x, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> y, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pxp, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pyp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a71dfee95a587378a161c3a6f1e3a1c30">affineXformPt</a> (<a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *vc, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> x, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> y, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *pxp, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *pyp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a460ad002ec6dc77f3646d19211c64e87">linearInterpolatePixelColor</a> (<a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *datas, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> wpls, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> w, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> h, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> x, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> y, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> colorval, <a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *pval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a8ba4329a3f5411ffe36f8dc180093f5a">linearInterpolatePixelGray</a> (<a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *datas, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> wpls, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> w, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> h, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> x, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> y, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> grayval, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *pval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a2d74fe926128c1ccde0705ddb807ec12">gaussjordan</a> (<a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> **a, <a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *b, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a0df76221b3ccc27bfb5d0e6da35dfd0f">pixAffineSequential</a> (<a class="el" href="struct_pix.html">PIX</a> *pixs, <a class="el" href="struct_pta.html">PTA</a> *ptad, <a class="el" href="struct_pta.html">PTA</a> *ptas, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> bw, <a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> bh)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="affine_8c.html#a073f1588e24855b59dcdd87afe3b6e6f">AlphaMaskBorderVals</a> [2]</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>3-pt affine transforms on images and coordinates, with sampling and interpolation; gauss-jordan solver </p>
<div class="fragment"><pre class="fragment">    Affine (3 pt) image transformation using a sampled
    (to nearest integer) transform on each dest point
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#a8e84c9c625b81eaa272a78ba32b2a7ea">pixAffineSampledPta</a>()
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#ab761f82134e4973ba70bb7d5bdb62542">pixAffineSampled</a>()

    Affine (3 pt) image transformation using interpolation 
    (or area mapping) for anti-aliasing images that are
    2, 4, or 8 bpp gray, or colormapped, or 32 bpp RGB
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#a2264192bf053eccba3233b9840590d6e">pixAffinePta</a>()
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#a6d86935bd696bd2431cd17136771c519">pixAffine</a>()
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#aed5a65a5f747035b9aad508afac6f67d">pixAffinePtaColor</a>()
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#a06d77d39bbd430ce000f88b7302d17b4">pixAffineColor</a>()
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#a5f2ec4d911f8f0388cc40ecf48cd0645">pixAffinePtaGray</a>()
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#a58c3e8f9e6e6d33e074aecfbbc1d310a">pixAffineGray</a>()

    Affine transform including alpha (blend) component and gamma transform
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#afd63168e13d35247c9e21d6e59f09567">pixAffinePtaWithAlpha</a>()
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#ac11c1ec1133dc6625c6c589bf4d54663">pixAffinePtaGammaXform</a>()

    Affine coordinate transformation
         <a class="code" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>     <a class="code" href="affine_8c.html#a6dbd9d7ffdcb98cb9bdeb3d1ca67e4c4">getAffineXformCoeffs</a>()
         <a class="code" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>     <a class="code" href="affine_8c.html#a4bec7268ce4521fcc08cb33b5e5c1c4a">affineInvertXform</a>()
         <a class="code" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>     <a class="code" href="affine_8c.html#adf6502edf7823f552db9236cba693dc3">affineXformSampledPt</a>()
         <a class="code" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>     <a class="code" href="affine_8c.html#a71dfee95a587378a161c3a6f1e3a1c30">affineXformPt</a>()

    Interpolation helper functions
         <a class="code" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>     <a class="code" href="affine_8c.html#a8ba4329a3f5411ffe36f8dc180093f5a">linearInterpolatePixelGray</a>()
         <a class="code" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>     <a class="code" href="affine_8c.html#a460ad002ec6dc77f3646d19211c64e87">linearInterpolatePixelColor</a>()

    Gauss-jordan linear equation solver
         <a class="code" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>     <a class="code" href="affine_8c.html#a2d74fe926128c1ccde0705ddb807ec12">gaussjordan</a>()

    Affine image transformation using a sequence of 
    shear/scale/translation operations
         <a class="code" href="struct_pix.html">PIX</a>        *<a class="code" href="affine_8c.html#a0df76221b3ccc27bfb5d0e6da35dfd0f">pixAffineSequential</a>()

    One can define a coordinate space by the location of the origin,
    the orientation of x and y axes, and the unit scaling along
    each axis.  An affine transform is a general linear
    transformation from one coordinate space to another.

    For the general case, we can define the affine transform using
    two sets of three (noncollinear) points in a plane.  One set
    corresponds to the input (src) coordinate space; the other to the 
    transformed (dest) coordinate space.  Each point in the
    src corresponds to one of the points in the dest.  With two
    sets of three points, we get a set of 6 equations in 6 unknowns
    that specifies the mapping between the coordinate spaces.
    The interface here allows you to specify either the corresponding
    sets of 3 points, or the transform itself (as a vector of 6
    coefficients).

    Given the transform as a vector of 6 coefficients, we can compute
    both a a pointwise affine coordinate transformation and an
    affine image transformation.

    To compute the coordinate transform, we need the coordinate
    value (x&#39;,y&#39;) in the transformed space for any point (x,y)
    in the original space.  To derive this transform from the
    three corresponding points, it is convenient to express the affine
    coordinate transformation using an LU decomposition of
    a set of six linear equations that express the six coordinates
    of the three points in the transformed space as a function of
    the six coordinates in the original space.  Once we have
    this transform matrix , we can transform an image by
    finding, for each destination pixel, the pixel (or pixels)
    in the source that give rise to it.

    This &#39;pointwise&#39; transformation can be done either by sampling
    and picking a single pixel in the src to replicate into the dest,
    or by interpolating (or averaging) over four src pixels to
    determine the value of the dest pixel.  The first method is
    implemented by <a class="code" href="affine_8c.html#ab761f82134e4973ba70bb7d5bdb62542">pixAffineSampled</a>() and the second method by
    <a class="code" href="affine_8c.html#a6d86935bd696bd2431cd17136771c519">pixAffine</a>().  The interpolated method can only be used for
    images with more than 1 bpp, but for these, the image quality
    is significantly better than the sampled method, due to
    the &#39;antialiasing&#39; effect of weighting the src pixels.

    Interpolation works well when there is relatively little scaling,
    or if there is image expansion in general.  However, if there
    is significant image reduction, one should apply a low-pass
    filter before subsampling to avoid aliasing the high frequencies.

    A typical application might be to align two images, which
    may be scaled, rotated and translated versions of each other.
    Through some pre-processing, three corresponding points are
    located in each of the two images.  One of the images is
    then to be (affine) transformed to align with the other.
    As mentioned, the standard way to do this is to use three
    sets of points, compute the 6 transformation coefficients
    from these points that describe the linear transformation,

        x&#39; = ax + by + c
        y&#39; = dx + ey + f

    and use this in a pointwise manner to transform the image.

    N.B.  Be sure to see the comment in <a class="code" href="affine_8c.html#a6dbd9d7ffdcb98cb9bdeb3d1ca67e4c4">getAffineXformCoeffs</a>(),
    regarding using the inverse of the affine transform for points
    to transform images.

    There is another way to do this transformation; namely,
    by doing a sequence of simple affine transforms, without
    computing directly the affine coordinate transformation.
    We have at our disposal (1) translations (using rasterop),
    (2) horizontal and vertical shear about any horizontal and vertical
    line, respectively, and (3) non-isotropic scaling by two
    arbitrary x and y scaling factors.  We also have rotation
    about an arbitrary point, but this is equivalent to a set 
    of three shears so we do not need to use it.

    Why might we do this?  For binary images, it is usually
    more efficient to do such transformations by a sequence
    of word parallel operations.  Shear and translation can be
    done in-place and word parallel; arbitrary scaling is
    mostly pixel-wise.

    Suppose that we are tranforming image 1 to correspond to image 2.
    We have a set of three points, describing the coordinate space
    embedded in image 1, and we need to transform image 1 until
    those three points exactly correspond to the new coordinate space
    defined by the second set of three points.  In our image
    matching application, the latter set of three points was
    found to be the corresponding points in image 2.

    The most elegant way I can think of to do such a sequential
    implementation is to imagine that we&#39;re going to transform
    BOTH images until they&#39;re aligned.  (We don&#39;t really want
    to transform both, because in fact we may only have one image
    that is undergoing a general affine transformation.)

    Choose the 3 corresponding points as follows:
       - The 1st point is an origin
       - The 2nd point gives the orientation and scaling of the
         &quot;x&quot; axis with respect to the origin
       - The 3rd point does likewise for the &quot;y&quot; axis.
    These &quot;axes&quot; must not be collinear; otherwise they are
    arbitrary (although some strange things will happen if
    the handedness sweeping through the minimum angle between
    the axes is opposite).

    An important constraint is that we have shear operations
    about an arbitrary horizontal or vertical line, but always
    parallel to the x or y axis.  If we continue to pretend that
    we have an unprimed coordinate space embedded in image 1 and
    a primed coordinate space embedded in image 2, we imagine
    (a) transforming image 1 by horizontal and vertical shears about
    point 1 to align points 3 and 2 along the y and x axes,
    respectively, and (b) transforming image 2 by horizontal and
    vertical shears about point 1&#39; to align points 3&#39; and 2&#39; along
    the y and x axes.  Then we scale image 1 so that the distances
    from 1 to 2 and from 1 to 3 are equal to the distances in
    image 2 from 1&#39; to 2&#39; and from 1&#39; to 3&#39;.  This scaling operation
    leaves the true image origin, at (0,0) invariant, and will in
    general translate point 1.  The original points 1 and 1&#39; will
    typically not coincide in any event, so we must translate
    the origin of image 1, at its current point 1, to the origin
    of image 2 at 1&#39;.  The images should now be aligned.  But
    because we never really transformed image 2 (and image 2 may
    not even exist), we now perform  on image 1 the reverse of
    the shear transforms that we imagined doing on image 2;
    namely, the negative vertical shear followed by the negative
    horizontal shear.  Image 1 should now have its transformed
    unprimed coordinates aligned with the original primed
    coordinates.  In all this, it is only necessary to keep track
    of the shear angles and translations of points during the shears.
    What has been accomplished is a general affine transformation
    on image 1.

    Having described all this, if you are going to use an
    affine transformation in an application, this is what you
    need to know:

        (1) You should NEVER use the sequential method, because
            the image quality for 1 bpp text is much poorer
            (even though it is about 2x faster than the pointwise sampled
            method), and for images with depth greater than 1, it is
            nearly 20x slower than the pointwise sampled method
            and over 10x slower than the pointwise interpolated method!
            The sequential method is given here for purely
            pedagogical reasons.

        (2) For 1 bpp images, use the pointwise sampled function
            <a class="code" href="affine_8c.html#ab761f82134e4973ba70bb7d5bdb62542">pixAffineSampled</a>().  For all other images, the best
            quality results result from using the pointwise
            interpolated function <a class="code" href="affine_8c.html#a2264192bf053eccba3233b9840590d6e">pixAffinePta</a>() or <a class="code" href="affine_8c.html#a6d86935bd696bd2431cd17136771c519">pixAffine</a>();
            the cost is less than a doubling of the computation time
            with respect to the sampled function.  If you use 
            interpolation on colormapped images, the colormap will
            be removed, resulting in either a grayscale or color
            image, depending on the values in the colormap.
            If you want to retain the colormap, use <a class="code" href="affine_8c.html#ab761f82134e4973ba70bb7d5bdb62542">pixAffineSampled</a>().

    Typical relative timing of pointwise transforms (sampled = 1.0):
    8 bpp:   sampled        1.0
             interpolated   1.6
    32 bpp:  sampled        1.0
             interpolated   1.8
    Additionally, the computation time/pixel is nearly the same
    for 8 bpp and 32 bpp, for both sampled and interpolated.
</pre></div> 
<p>Definition in file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="ad72dbcf6d0153db1b8d8a58001feed83"></a><!-- doxytag: member="affine.c::DEBUG" ref="ad72dbcf6d0153db1b8d8a58001feed83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="affine_8c_source.html#l00232">232</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

</div>
</div>
<a class="anchor" id="aac9153aee4bdb92701df902e06a74eb3"></a><!-- doxytag: member="affine.c::SWAP" ref="aac9153aee4bdb92701df902e06a74eb3" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SWAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;{temp = (a); (a) = (b); (b) = temp;}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="affine_8c_source.html#l01318">1318</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l01337">gaussjordan()</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8e84c9c625b81eaa272a78ba32b2a7ea"></a><!-- doxytag: member="affine.c::pixAffineSampledPta" ref="a8e84c9c625b81eaa272a78ba32b2a7ea" args="(PIX *pixs, PTA *ptad, PTA *ptas, l_int32 incolor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffineSampledPta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>incolor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a8e84c9c625b81eaa272a78ba32b2a7ea">pixAffineSampledPta()</a></p>
<p>Input: pixs (all depths) ptad (3 pts of final coordinate space) ptas (3 pts of initial coordinate space) incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK) Return: pixd, or null on error</p>
<p>Notes: (1) Brings in either black or white pixels from the boundary. (2) Retains colormap, which you can do for a sampled transform.. (3) The 3 points must not be collinear. (4) The order of the 3 points is arbitrary; however, to compare with the sequential transform they must be in these locations and in this order: origin, x-axis, y-axis. (5) For 1 bpp images, this has much better quality results than <a class="el" href="affine_8c.html#a0df76221b3ccc27bfb5d0e6da35dfd0f">pixAffineSequential()</a>, particularly for text. It is about 3x slower, but does not require additional border pixels. The poor quality of <a class="el" href="affine_8c.html#a0df76221b3ccc27bfb5d0e6da35dfd0f">pixAffineSequential()</a> is due to repeated quantized transforms. It is strongly recommended that <a class="el" href="affine_8c.html#ab761f82134e4973ba70bb7d5bdb62542">pixAffineSampled()</a> be used for 1 bpp images. (6) For 8 or 32 bpp, much better quality is obtained by the somewhat slower <a class="el" href="affine_8c.html#a2264192bf053eccba3233b9840590d6e">pixAffinePta()</a>. See that function for relative timings between sampled and interpolated. (7) To repeat, use of the sequential transform, <a class="el" href="affine_8c.html#a0df76221b3ccc27bfb5d0e6da35dfd0f">pixAffineSequential()</a>, for any images, is discouraged. </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00268">268</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="affine_8c_source.html#l00954">getAffineXformCoeffs()</a>, <a class="el" href="pix_8h_source.html#l00695">L_BRING_IN_BLACK</a>, <a class="el" href="pix_8h_source.html#l00694">L_BRING_IN_WHITE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="affine_8c_source.html#l00316">pixAffineSampled()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="ptabasic_8c_source.html#l00346">ptaGetCount()</a>.</p>

<p>Referenced by <a class="el" href="affine__reg_8c_source.html#l00056">main()</a>, and <a class="el" href="affine_8c_source.html#l00411">pixAffinePta()</a>.</p>

</div>
</div>
<a class="anchor" id="ab761f82134e4973ba70bb7d5bdb62542"></a><!-- doxytag: member="affine.c::pixAffineSampled" ref="ab761f82134e4973ba70bb7d5bdb62542" args="(PIX *pixs, l_float32 *vc, l_int32 incolor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffineSampled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>incolor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#ab761f82134e4973ba70bb7d5bdb62542">pixAffineSampled()</a></p>
<p>Input: pixs (all depths) vc (vector of 6 coefficients for affine transformation) incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK) Return: pixd, or null on error</p>
<p>Notes: (1) Brings in either black or white pixels from the boundary. (2) Retains colormap, which you can do for a sampled transform.. (3) For 8 or 32 bpp, much better quality is obtained by the somewhat slower <a class="el" href="affine_8c.html#a6d86935bd696bd2431cd17136771c519">pixAffine()</a>. See that function for relative timings between sampled and interpolated. </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00316">316</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="affine_8c_source.html#l01118">affineXformSampledPt()</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="arrayaccess_8h_source.html#l00060">GET_DATA_BIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00080">GET_DATA_DIBIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00097">GET_DATA_QBIT</a>, <a class="el" href="pix_8h_source.html#l00695">L_BRING_IN_BLACK</a>, <a class="el" href="pix_8h_source.html#l00694">L_BRING_IN_WHITE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix2_8c_source.html#l00598">pixClearAll()</a>, <a class="el" href="colormap_8c_source.html#l00446">pixcmapAddBlackOrWhite()</a>, <a class="el" href="pix1_8c_source.html#l00328">pixCreateTemplate()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix2_8c_source.html#l00625">pixSetAll()</a>, <a class="el" href="pix2_8c_source.html#l00661">pixSetAllArbitrary()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="arrayaccess_8h_source.html#l00069">SET_DATA_BIT_VAL</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="arrayaccess_8h_source.html#l00083">SET_DATA_DIBIT</a>, <a class="el" href="arrayaccess_8h_source.html#l00100">SET_DATA_QBIT</a>, <a class="el" href="heap__reg_8c_source.html#l00026">HeapElement::x</a>, and <a class="el" href="heap__reg_8c_source.html#l00027">HeapElement::y</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00479">pixAffine()</a>, and <a class="el" href="affine_8c_source.html#l00268">pixAffineSampledPta()</a>.</p>

</div>
</div>
<a class="anchor" id="a2264192bf053eccba3233b9840590d6e"></a><!-- doxytag: member="affine.c::pixAffinePta" ref="a2264192bf053eccba3233b9840590d6e" args="(PIX *pixs, PTA *ptad, PTA *ptas, l_int32 incolor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffinePta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>incolor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a2264192bf053eccba3233b9840590d6e">pixAffinePta()</a></p>
<p>Input: pixs (all depths; colormap ok) ptad (3 pts of final coordinate space) ptas (3 pts of initial coordinate space) incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK) Return: pixd, or null on error</p>
<p>Notes: (1) Brings in either black or white pixels from the boundary (2) Removes any existing colormap, if necessary, before transforming </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00411">411</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00179">FALSE</a>, <a class="el" href="pix_8h_source.html#l00695">L_BRING_IN_BLACK</a>, <a class="el" href="pix_8h_source.html#l00694">L_BRING_IN_WHITE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="affine_8c_source.html#l00535">pixAffinePtaColor()</a>, <a class="el" href="affine_8c_source.html#l00629">pixAffinePtaGray()</a>, <a class="el" href="affine_8c_source.html#l00268">pixAffineSampledPta()</a>, <a class="el" href="pix1_8c_source.html#l00440">pixClone()</a>, <a class="el" href="pixconv_8c_source.html#l02297">pixConvertTo8()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="ptabasic_8c_source.html#l00346">ptaGetCount()</a>, and <a class="el" href="pix_8h_source.html#l00181">REMOVE_CMAP_BASED_ON_SRC</a>.</p>

<p>Referenced by <a class="el" href="affine__reg_8c_source.html#l00056">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d86935bd696bd2431cd17136771c519"></a><!-- doxytag: member="affine.c::pixAffine" ref="a6d86935bd696bd2431cd17136771c519" args="(PIX *pixs, l_float32 *vc, l_int32 incolor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>incolor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a6d86935bd696bd2431cd17136771c519">pixAffine()</a></p>
<p>Input: pixs (all depths; colormap ok) vc (vector of 6 coefficients for affine transformation) incolor (L_BRING_IN_WHITE, L_BRING_IN_BLACK) Return: pixd, or null on error</p>
<p>Notes: (1) Brings in either black or white pixels from the boundary (2) Removes any existing colormap, if necessary, before transforming </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00479">479</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00179">FALSE</a>, <a class="el" href="pix_8h_source.html#l00694">L_BRING_IN_WHITE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="affine_8c_source.html#l00576">pixAffineColor()</a>, <a class="el" href="affine_8c_source.html#l00671">pixAffineGray()</a>, <a class="el" href="affine_8c_source.html#l00316">pixAffineSampled()</a>, <a class="el" href="pix1_8c_source.html#l00440">pixClone()</a>, <a class="el" href="pixconv_8c_source.html#l02297">pixConvertTo8()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pixconv_8c_source.html#l00223">pixRemoveColormap()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="pix_8h_source.html#l00181">REMOVE_CMAP_BASED_ON_SRC</a>.</p>

<p>Referenced by <a class="el" href="affine__reg_8c_source.html#l00056">main()</a>.</p>

</div>
</div>
<a class="anchor" id="aed5a65a5f747035b9aad508afac6f67d"></a><!-- doxytag: member="affine.c::pixAffinePtaColor" ref="aed5a65a5f747035b9aad508afac6f67d" args="(PIX *pixs, PTA *ptad, PTA *ptas, l_uint32 colorval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffinePtaColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a>&#160;</td>
          <td class="paramname"><em>colorval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#aed5a65a5f747035b9aad508afac6f67d">pixAffinePtaColor()</a></p>
<p>Input: pixs (32 bpp) ptad (3 pts of final coordinate space) ptas (3 pts of initial coordinate space) colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE) Return: pixd, or null on error </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00535">535</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="affine_8c_source.html#l00954">getAffineXformCoeffs()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="affine_8c_source.html#l00576">pixAffineColor()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="ptabasic_8c_source.html#l00346">ptaGetCount()</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00411">pixAffinePta()</a>, and <a class="el" href="affine_8c_source.html#l00757">pixAffinePtaWithAlpha()</a>.</p>

</div>
</div>
<a class="anchor" id="a06d77d39bbd430ce000f88b7302d17b4"></a><!-- doxytag: member="affine.c::pixAffineColor" ref="a06d77d39bbd430ce000f88b7302d17b4" args="(PIX *pixs, l_float32 *vc, l_uint32 colorval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffineColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a>&#160;</td>
          <td class="paramname"><em>colorval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a06d77d39bbd430ce000f88b7302d17b4">pixAffineColor()</a></p>
<p>Input: pixs (32 bpp) vc (vector of 6 coefficients for affine transformation) colorval (e.g., 0 to bring in BLACK, 0xffffff00 for WHITE) Return: pixd, or null on error </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00576">576</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="affine_8c_source.html#l01148">affineXformPt()</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="affine_8c_source.html#l01187">linearInterpolatePixelColor()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l00328">pixCreateTemplate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix2_8c_source.html#l00661">pixSetAllArbitrary()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="heap__reg_8c_source.html#l00026">HeapElement::x</a>, and <a class="el" href="heap__reg_8c_source.html#l00027">HeapElement::y</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00479">pixAffine()</a>, and <a class="el" href="affine_8c_source.html#l00535">pixAffinePtaColor()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f2ec4d911f8f0388cc40ecf48cd0645"></a><!-- doxytag: member="affine.c::pixAffinePtaGray" ref="a5f2ec4d911f8f0388cc40ecf48cd0645" args="(PIX *pixs, PTA *ptad, PTA *ptas, l_uint8 grayval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffinePtaGray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a7ed60554e7d6dd89aca643189b1e70ad">l_uint8</a>&#160;</td>
          <td class="paramname"><em>grayval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a5f2ec4d911f8f0388cc40ecf48cd0645">pixAffinePtaGray()</a></p>
<p>Input: pixs (8 bpp) ptad (3 pts of final coordinate space) ptas (3 pts of initial coordinate space) grayval (0 to bring in BLACK, 255 for WHITE) Return: pixd, or null on error </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00629">629</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="affine_8c_source.html#l00954">getAffineXformCoeffs()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="affine_8c_source.html#l00671">pixAffineGray()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="ptabasic_8c_source.html#l00346">ptaGetCount()</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00411">pixAffinePta()</a>, and <a class="el" href="affine_8c_source.html#l00757">pixAffinePtaWithAlpha()</a>.</p>

</div>
</div>
<a class="anchor" id="a58c3e8f9e6e6d33e074aecfbbc1d310a"></a><!-- doxytag: member="affine.c::pixAffineGray" ref="a58c3e8f9e6e6d33e074aecfbbc1d310a" args="(PIX *pixs, l_float32 *vc, l_uint8 grayval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffineGray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a7ed60554e7d6dd89aca643189b1e70ad">l_uint8</a>&#160;</td>
          <td class="paramname"><em>grayval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a58c3e8f9e6e6d33e074aecfbbc1d310a">pixAffineGray()</a></p>
<p>Input: pixs (8 bpp) vc (vector of 6 coefficients for affine transformation) grayval (0 to bring in BLACK, 255 for WHITE) Return: pixd, or null on error </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00671">671</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="affine_8c_source.html#l01148">affineXformPt()</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="affine_8c_source.html#l01267">linearInterpolatePixelGray()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix1_8c_source.html#l00328">pixCreateTemplate()</a>, <a class="el" href="pix1_8c_source.html#l01358">pixGetData()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix1_8c_source.html#l00970">pixGetWpl()</a>, <a class="el" href="pix2_8c_source.html#l00661">pixSetAllArbitrary()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="arrayaccess_8h_source.html#l00126">SET_DATA_BYTE</a>, <a class="el" href="heap__reg_8c_source.html#l00026">HeapElement::x</a>, and <a class="el" href="heap__reg_8c_source.html#l00027">HeapElement::y</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00479">pixAffine()</a>, and <a class="el" href="affine_8c_source.html#l00629">pixAffinePtaGray()</a>.</p>

</div>
</div>
<a class="anchor" id="afd63168e13d35247c9e21d6e59f09567"></a><!-- doxytag: member="affine.c::pixAffinePtaWithAlpha" ref="afd63168e13d35247c9e21d6e59f09567" args="(PIX *pixs, PTA *ptad, PTA *ptas, PIX *pixg, l_float32 fract, l_int32 border)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffinePtaWithAlpha </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>fract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>border</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#afd63168e13d35247c9e21d6e59f09567">pixAffinePtaWithAlpha()</a></p>
<p>Input: pixs (32 bpp rgb) ptad (3 pts of final coordinate space) ptas (3 pts of initial coordinate space) pixg (&lt;optional&gt; 8 bpp, can be null) fract (between 0.0 and 1.0, with 0.0 fully transparent and 1.0 fully opaque) border (of pixels added to capture transformed source pixels) Return: pixd, or null on error</p>
<p>Notes: (1) The alpha channel is transformed separately from pixs, and aligns with it, being fully transparent outside the boundary of the transformed pixs. For pixels that are fully transparent, a blending function like <a class="el" href="blend_8c.html#a51d08d3ae19c515a5fabf42db1daf85b">pixBlendWithGrayMask()</a> will give zero weight to corresponding pixels in pixs. (2) If pixg is NULL, it is generated as an alpha layer that is partially opaque, using . Otherwise, it is cropped to pixs if required and  is ignored. The alpha channel in pixs is never used. (3) Colormaps are removed. (4) When pixs is transformed, it doesn't matter what color is brought in because the alpha channel will be transparent (0) there. (5) To avoid losing source pixels in the destination, it may be necessary to add a border to the source pix before doing the affine transformation. This can be any non-negative number. (6) The input  and  are in a coordinate space before the border is added. Internally, we compensate for this before doing the affine transform on the image after the border is added. (7) The default setting for the border values in the alpha channel is 0 (transparent) for the outermost ring of pixels and (0.5 * fract * 255) for the second ring. When blended over a second image, this (a) shrinks the visible image to make a clean overlap edge with an image below, and (b) softens the edges by weakening the aliasing there. Use <a class="el" href="leptprotos_8h.html#ab264c4aa44066ad46ebe2294b8bb523b">l_setAlphaMaskBorder()</a> to change these values. </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00757">757</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="pix2_8c_source.html#l00117">AlphaMaskBorderVals</a>, <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix_8h_source.html#l00146">L_ALPHA_CHANNEL</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix2_8c_source.html#l01463">pixAddBorder()</a>, <a class="el" href="affine_8c_source.html#l00535">pixAffinePtaColor()</a>, <a class="el" href="affine_8c_source.html#l00629">pixAffinePtaGray()</a>, <a class="el" href="pix1_8c_source.html#l00269">pixCreate()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="pix1_8c_source.html#l01288">pixGetColormap()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, <a class="el" href="pix1_8c_source.html#l00898">pixGetDimensions()</a>, <a class="el" href="pix5_8c_source.html#l00835">pixResizeToMatch()</a>, <a class="el" href="pix2_8c_source.html#l00625">pixSetAll()</a>, <a class="el" href="pix2_8c_source.html#l00661">pixSetAllArbitrary()</a>, <a class="el" href="pix2_8c_source.html#l01313">pixSetBorderRingVal()</a>, <a class="el" href="pix2_8c_source.html#l01940">pixSetRGBComponent()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="ptabasic_8c_source.html#l00156">ptaDestroy()</a>, and <a class="el" href="ptafunc1_8c_source.html#l00735">ptaTransform()</a>.</p>

<p>Referenced by <a class="el" href="alphaxform__reg_8c_source.html#l00054">main()</a>, and <a class="el" href="affine_8c_source.html#l00853">pixAffinePtaGammaXform()</a>.</p>

</div>
</div>
<a class="anchor" id="ac11c1ec1133dc6625c6c589bf4d54663"></a><!-- doxytag: member="affine.c::pixAffinePtaGammaXform" ref="ac11c1ec1133dc6625c6c589bf4d54663" args="(PIX *pixs, l_float32 gamma, PTA *ptad, PTA *ptas, l_float32 fract, l_int32 border)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffinePtaGammaXform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>fract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>border</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#ac11c1ec1133dc6625c6c589bf4d54663">pixAffinePtaGammaXform()</a></p>
<p>Input: pixs (32 bpp rgb) gamma (gamma correction; must be &gt; 0.0) ptad (3 pts of final coordinate space) ptas (3 pts of initial coordinate space) fract (between 0.0 and 1.0, with 1.0 fully transparent) border (of pixels to capture transformed source pixels) Return: pixd, or null on error</p>
<p>Notes: (1) This wraps a gamma/inverse-gamma photometric transform around <a class="el" href="affine_8c.html#afd63168e13d35247c9e21d6e59f09567">pixAffinePtaWithAlpha()</a>. (2) For usage, see notes in <a class="el" href="affine_8c.html#afd63168e13d35247c9e21d6e59f09567">pixAffinePtaWithAlpha()</a> and <a class="el" href="enhance_8c.html#ade289b100cd6316d6ef34d40beb375c2">pixGammaTRCWithAlpha()</a>. (3) The basic idea of a gamma/inverse-gamma transform is to remove any gamma correction before the affine transform, and restore it afterward. The effects can be subtle, but important for some applications. For example, using gamma &gt; 1.0 will cause the dark areas to become somewhat lighter and slightly reduce aliasing effects when blending using the alpha channel. </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00853">853</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="environ_8h_source.html#l00257">L_WARNING</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="affine_8c_source.html#l00757">pixAffinePtaWithAlpha()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="enhance_8c_source.html#l00281">pixGammaTRCWithAlpha()</a>, <a class="el" href="pix1_8c_source.html#l00863">pixGetDepth()</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="alphaxform__reg_8c_source.html#l00054">main()</a>.</p>

</div>
</div>
<a class="anchor" id="a6dbd9d7ffdcb98cb9bdeb3d1ca67e4c4"></a><!-- doxytag: member="affine.c::getAffineXformCoeffs" ref="a6dbd9d7ffdcb98cb9bdeb3d1ca67e4c4" args="(PTA *ptas, PTA *ptad, l_float32 **pvc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> getAffineXformCoeffs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> **&#160;</td>
          <td class="paramname"><em>pvc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a6dbd9d7ffdcb98cb9bdeb3d1ca67e4c4">getAffineXformCoeffs()</a></p>
<p>Input: ptas (source 3 points; unprimed) ptad (transformed 3 points; primed) &amp;vc (&lt;return&gt; vector of coefficients of transform) Return: 0 if OK; 1 on error</p>
<p>We have a set of six equations, describing the affine transformation that takes 3 points (ptas) into 3 other points (ptad). These equations are:</p>
<p>x1' = c[0]*x1 + c[1]*y1 + c[2] y1' = c[3]*x1 + c[4]*y1 + c[5] x2' = c[0]*x2 + c[1]*y2 + c[2] y2' = c[3]*x2 + c[4]*y2 + c[5] x3' = c[0]*x3 + c[1]*y3 + c[2] y3' = c[3]*x3 + c[4]*y3 + c[5]</p>
<p>This can be represented as</p>
<p>AC = B</p>
<p>where B and C are column vectors</p>
<p>B = [ x1' y1' x2' y2' x3' y3' ] C = [ c[0] c[1] c[2] c[3] c[4] c[5] c[6] ]</p>
<p>and A is the 6x6 matrix</p>
<p>x1 y1 1 0 0 0 0 0 0 x1 y1 1 x2 y2 1 0 0 0 0 0 0 x2 y2 1 x3 y3 1 0 0 0 0 0 0 x3 y3 1</p>
<p>These six equations are solved here for the coefficients C.</p>
<p>These six coefficients can then be used to find the dest point (x',y') corresponding to any src point (x,y), according to the equations</p>
<p>x' = c[0]x + c[1]y + c[2] y' = c[3]x + c[4]y + c[5]</p>
<p>that are implemented in <a class="el" href="affine_8c.html#a71dfee95a587378a161c3a6f1e3a1c30">affineXformPt()</a>.</p>
<p>!!!!!!!!!!!!!!!!!! Very important !!!!!!!!!!!!!!!!!!!!!!</p>
<p>When the affine transform is composed from a set of simple operations such as translation, scaling and rotation, it is built in a form to convert from the un-transformed src point to the transformed dest point. However, when an affine transform is used on images, it is used in an inverted way: it converts from the transformed dest point to the un-transformed src point. So, for example, if you transform a boxa using transform A, to transform an image in the same way you must use the inverse of A.</p>
<p>For example, if you transform a boxa with a 3x3 affine matrix 'mat', the analogous image transformation must use 'matinv':</p>
<p>boxad = boxaAffineTransform(boxas, mat); affineInvertXform(mat, &amp;matinv); pixd = pixAffine(pixs, matinv, L_BRING_IN_WHITE);</p>
<p>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l00954">954</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="affine_8c_source.html#l01337">gaussjordan()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="ptabasic_8c_source.html#l00367">ptaGetPt()</a>, <a class="el" href="affine__reg_8c_source.html#l00032">x1</a>, <a class="el" href="affine__reg_8c_source.html#l00034">x2</a>, <a class="el" href="affine__reg_8c_source.html#l00036">x3</a>, <a class="el" href="affine__reg_8c_source.html#l00033">y1</a>, <a class="el" href="affine__reg_8c_source.html#l00035">y2</a>, and <a class="el" href="affine__reg_8c_source.html#l00037">y3</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00535">pixAffinePtaColor()</a>, <a class="el" href="affine_8c_source.html#l00629">pixAffinePtaGray()</a>, and <a class="el" href="affine_8c_source.html#l00268">pixAffineSampledPta()</a>.</p>

</div>
</div>
<a class="anchor" id="a4bec7268ce4521fcc08cb33b5e5c1c4a"></a><!-- doxytag: member="affine.c::affineInvertXform" ref="a4bec7268ce4521fcc08cb33b5e5c1c4a" args="(l_float32 *vc, l_float32 **pvci)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> affineInvertXform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> **&#160;</td>
          <td class="paramname"><em>pvci</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a4bec7268ce4521fcc08cb33b5e5c1c4a">affineInvertXform()</a></p>
<p>Input: vc (vector of 6 coefficients) *vci (&lt;return&gt; inverted transform) Return: 0 if OK; 1 on error</p>
<p>Notes: (1) The 6 affine transform coefficients are the first two rows of a 3x3 matrix where the last row has only a 1 in the third column. We invert this using <a class="el" href="affine_8c.html#a2d74fe926128c1ccde0705ddb807ec12">gaussjordan()</a>, and select the first 2 rows as the coefficients of the inverse affine transform. (2) Alternatively, we can find the inverse transform coefficients by inverting the 2x2 submatrix, and treating the top 2 coefficients in the 3rd column as a RHS vector for that 2x2 submatrix. Then the 6 inverted transform coefficients are composed of the inverted 2x2 submatrix and the negative of the transformed RHS vector. Why is this so? We have Y = AX + R (2 equations in 6 unknowns) Then X = A'Y - A'R Gauss-jordan solves AF = R and puts the solution for F, which is A'R, into the input R vector. </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l01045">1045</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="affine_8c_source.html#l01337">gaussjordan()</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="affine__reg_8c_source.html#l00056">main()</a>.</p>

</div>
</div>
<a class="anchor" id="adf6502edf7823f552db9236cba693dc3"></a><!-- doxytag: member="affine.c::affineXformSampledPt" ref="adf6502edf7823f552db9236cba693dc3" args="(l_float32 *vc, l_int32 x, l_int32 y, l_int32 *pxp, l_int32 *pyp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> affineXformSampledPt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pxp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pyp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#adf6502edf7823f552db9236cba693dc3">affineXformSampledPt()</a></p>
<p>Input: vc (vector of 6 coefficients) (x, y) (initial point) (&amp;xp, &amp;yp) (&lt;return&gt; transformed point) Return: 0 if OK; 1 on error</p>
<p>Notes: (1) This finds the nearest pixel coordinates of the transformed point. (2) It does not check ptrs for returned data! </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l01118">1118</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00316">pixAffineSampled()</a>.</p>

</div>
</div>
<a class="anchor" id="a71dfee95a587378a161c3a6f1e3a1c30"></a><!-- doxytag: member="affine.c::affineXformPt" ref="a71dfee95a587378a161c3a6f1e3a1c30" args="(l_float32 *vc, l_int32 x, l_int32 y, l_float32 *pxp, l_float32 *pyp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> affineXformPt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>vc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>pxp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>pyp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a71dfee95a587378a161c3a6f1e3a1c30">affineXformPt()</a></p>
<p>Input: vc (vector of 6 coefficients) (x, y) (initial point) (&amp;xp, &amp;yp) (&lt;return&gt; transformed point) Return: 0 if OK; 1 on error</p>
<p>Notes: (1) This computes the floating point location of the transformed point. (2) It does not check ptrs for returned data! </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l01148">1148</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00576">pixAffineColor()</a>, and <a class="el" href="affine_8c_source.html#l00671">pixAffineGray()</a>.</p>

</div>
</div>
<a class="anchor" id="a460ad002ec6dc77f3646d19211c64e87"></a><!-- doxytag: member="affine.c::linearInterpolatePixelColor" ref="a460ad002ec6dc77f3646d19211c64e87" args="(l_uint32 *datas, l_int32 wpls, l_int32 w, l_int32 h, l_float32 x, l_float32 y, l_uint32 colorval, l_uint32 *pval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> linearInterpolatePixelColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>datas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>wpls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a>&#160;</td>
          <td class="paramname"><em>colorval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>pval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a460ad002ec6dc77f3646d19211c64e87">linearInterpolatePixelColor()</a></p>
<p>Input: datas (ptr to beginning of image data) wpls (32-bit word/line for this data array) w, h (of image) x, y (floating pt location for evaluation) colorval (color brought in from the outside when the input x,y location is outside the image; in 0xrrggbb00 format)) &amp;val (&lt;return&gt; interpolated color value) Return: 0 if OK, 1 on error</p>
<p>Notes: (1) This is a standard linear interpolation function. It is equivalent to area weighting on each component, and avoids "jaggies" when rendering sharp edges. </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l01187">1187</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="pix_8h_source.html#l00153">L_BLUE_SHIFT</a>, <a class="el" href="pix_8h_source.html#l00151">L_GREEN_SHIFT</a>, <a class="el" href="pix_8h_source.html#l00149">L_RED_SHIFT</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00576">pixAffineColor()</a>, <a class="el" href="bilinear_8c_source.html#l00438">pixBilinearColor()</a>, and <a class="el" href="projective_8c_source.html#l00436">pixProjectiveColor()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ba4329a3f5411ffe36f8dc180093f5a"></a><!-- doxytag: member="affine.c::linearInterpolatePixelGray" ref="a8ba4329a3f5411ffe36f8dc180093f5a" args="(l_uint32 *datas, l_int32 wpls, l_int32 w, l_int32 h, l_float32 x, l_float32 y, l_int32 grayval, l_int32 *pval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> linearInterpolatePixelGray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a4d4d7254020fc95aef5dde8884405358">l_uint32</a> *&#160;</td>
          <td class="paramname"><em>datas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>wpls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>grayval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> *&#160;</td>
          <td class="paramname"><em>pval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a8ba4329a3f5411ffe36f8dc180093f5a">linearInterpolatePixelGray()</a></p>
<p>Input: datas (ptr to beginning of image data) wpls (32-bit word/line for this data array) w, h (of image) x, y (floating pt location for evaluation) grayval (color brought in from the outside when the input x,y location is outside the image) &amp;val (&lt;return&gt; interpolated gray value) Return: 0 if OK, 1 on error</p>
<p>Notes: (1) This is a standard linear interpolation function. It is equivalent to area weighting on each component, and avoids "jaggies" when rendering sharp edges. </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l01267">1267</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="arrayaccess_8h_source.html#l00118">GET_DATA_BYTE</a>, and <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l00671">pixAffineGray()</a>, <a class="el" href="bilinear_8c_source.html#l00532">pixBilinearGray()</a>, <a class="el" href="projective_8c_source.html#l00531">pixProjectiveGray()</a>, and <a class="el" href="warper_8c_source.html#l00166">pixRandomHarmonicWarp()</a>.</p>

</div>
</div>
<a class="anchor" id="a2d74fe926128c1ccde0705ddb807ec12"></a><!-- doxytag: member="affine.c::gaussjordan" ref="a2d74fe926128c1ccde0705ddb807ec12" args="(l_float32 **a, l_float32 *b, l_int32 n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a> gaussjordan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> **&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a2d74fe926128c1ccde0705ddb807ec12">gaussjordan()</a></p>
<p>Input: a (n x n matrix) b (rhs column vector) n (dimension) Return: 0 if ok, 1 on error</p>
<p>Note side effects: (1) the matrix a is transformed to its inverse (2) the vector b is transformed to the solution X to the linear equation AX = B</p>
<p>Adapted from "Numerical Recipes in C, Second Edition", 1992 pp. 36-41 (gauss-jordan elimination) </p>

<p>Definition at line <a class="el" href="affine_8c_source.html#l01337">1337</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00214">CALLOC</a>, <a class="el" href="environ_8h_source.html#l00251">ERROR_INT</a>, <a class="el" href="environ_8h_source.html#l00216">FREE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, and <a class="el" href="affine_8c_source.html#l01318">SWAP</a>.</p>

<p>Referenced by <a class="el" href="affine_8c_source.html#l01045">affineInvertXform()</a>, <a class="el" href="affine_8c_source.html#l00954">getAffineXformCoeffs()</a>, <a class="el" href="bilinear_8c_source.html#l00798">getBilinearXformCoeffs()</a>, <a class="el" href="projective_8c_source.html#l00800">getProjectiveXformCoeffs()</a>, <a class="el" href="yuvtest_8c_source.html#l00032">main()</a>, <a class="el" href="ptafunc1_8c_source.html#l01006">ptaGetCubicLSF()</a>, <a class="el" href="ptafunc1_8c_source.html#l00892">ptaGetQuadraticLSF()</a>, and <a class="el" href="ptafunc1_8c_source.html#l01137">ptaGetQuarticLSF()</a>.</p>

</div>
</div>
<a class="anchor" id="a0df76221b3ccc27bfb5d0e6da35dfd0f"></a><!-- doxytag: member="affine.c::pixAffineSequential" ref="a0df76221b3ccc27bfb5d0e6da35dfd0f" args="(PIX *pixs, PTA *ptad, PTA *ptas, l_int32 bw, l_int32 bh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_pix.html">PIX</a>* pixAffineSequential </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_pix.html">PIX</a> *&#160;</td>
          <td class="paramname"><em>pixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_pta.html">PTA</a> *&#160;</td>
          <td class="paramname"><em>ptas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="environ_8h.html#a9085c7874153c280a4171244aa052e4e">l_int32</a>&#160;</td>
          <td class="paramname"><em>bh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="affine_8c.html#a0df76221b3ccc27bfb5d0e6da35dfd0f">pixAffineSequential()</a></p>
<p>Input: pixs ptad (3 pts of final coordinate space) ptas (3 pts of initial coordinate space) bw (pixels of additional border width during computation) bh (pixels of additional border height during computation) Return: pixd, or null on error</p>
<p>Notes: (1) The 3 pts must not be collinear. (2) The 3 pts must be given in this order:</p>
<ul>
<li>origin</li>
<li>a location along the x-axis</li>
<li>a location along the y-axis. (3) You must guess how much border must be added so that no pixels are lost in the transformations from src to dest coordinate space. (This can be calculated but it is a lot of work!) For coordinate spaces that are nearly at right angles, on a 300 ppi scanned page, the addition of 1000 pixels on each side is usually sufficient. (4) This is here for pedagogical reasons. It is about 3x faster on 1 bpp images than <a class="el" href="affine_8c.html#ab761f82134e4973ba70bb7d5bdb62542">pixAffineSampled()</a>, but the results on text are much inferior. </li>
</ul>

<p>Definition at line <a class="el" href="affine_8c_source.html#l01446">1446</a> of file <a class="el" href="affine_8c_source.html">affine.c</a>.</p>

<p>References <a class="el" href="environ_8h_source.html#l00250">ERROR_PTR</a>, <a class="el" href="pix_8h_source.html#l00694">L_BRING_IN_WHITE</a>, <a class="el" href="environ_8h_source.html#l00171">NULL</a>, <a class="el" href="pix2_8c_source.html#l01531">pixAddBorderGeneral()</a>, <a class="el" href="pix1_8c_source.html#l00440">pixClone()</a>, <a class="el" href="pix1_8c_source.html#l00548">pixCopy()</a>, <a class="el" href="pix1_8c_source.html#l00466">pixDestroy()</a>, <a class="el" href="shear_8c_source.html#l00434">pixHShearIP()</a>, <a class="el" href="rop_8c_source.html#l00442">pixRasteropIP()</a>, <a class="el" href="pix2_8c_source.html#l01608">pixRemoveBorderGeneral()</a>, <a class="el" href="scale_8c_source.html#l00181">pixScale()</a>, <a class="el" href="shear_8c_source.html#l00504">pixVShearIP()</a>, <a class="el" href="environ_8h_source.html#l00249">PROCNAME</a>, <a class="el" href="ptabasic_8c_source.html#l00346">ptaGetCount()</a>, <a class="el" href="ptabasic_8c_source.html#l00397">ptaGetIPt()</a>, <a class="el" href="affine__reg_8c_source.html#l00032">x1</a>, <a class="el" href="affine__reg_8c_source.html#l00034">x2</a>, <a class="el" href="affine__reg_8c_source.html#l00036">x3</a>, <a class="el" href="affine__reg_8c_source.html#l00033">y1</a>, <a class="el" href="affine__reg_8c_source.html#l00035">y2</a>, and <a class="el" href="affine__reg_8c_source.html#l00037">y3</a>.</p>

<p>Referenced by <a class="el" href="affine__reg_8c_source.html#l00056">main()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a073f1588e24855b59dcdd87afe3b6e6f"></a><!-- doxytag: member="affine.c::AlphaMaskBorderVals" ref="a073f1588e24855b59dcdd87afe3b6e6f" args="[2]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="environ_8h.html#af59419416d96ecf5fca70c8d05adb456">l_float32</a> <a class="el" href="scale_8c.html#a073f1588e24855b59dcdd87afe3b6e6f">AlphaMaskBorderVals</a>[2]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="pix2_8c_source.html#l00117">117</a> of file <a class="el" href="pix2_8c_source.html">pix2.c</a>.</p>

<p>Referenced by <a class="el" href="pix2_8c_source.html#l02657">l_setAlphaMaskBorder()</a>, <a class="el" href="affine_8c_source.html#l00757">pixAffinePtaWithAlpha()</a>, <a class="el" href="bilinear_8c_source.html#l00618">pixBilinearPtaWithAlpha()</a>, <a class="el" href="projective_8c_source.html#l00618">pixProjectivePtaWithAlpha()</a>, <a class="el" href="rotate_8c_source.html#l00492">pixRotateWithAlpha()</a>, and <a class="el" href="scale_8c_source.html#l03065">pixScaleWithAlpha()</a>.</p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="affine_8c.html">affine.c</a>      </li>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
